;; ASM: Final program
;; Program kind: Contract
.program:
move $$tmp $pc
jmpf $zero i2
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i48                      ; stack space for globals
addr $$arg0 data_0            ; ptr to PRICE_DECIMALS default value
addi $$arg1 $zero i4          ; length of PRICE_DECIMALS default value
addi $$arg2 $ssp i0           ; ptr to global PRICE_DECIMALS stack address
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4
jmpf $zero i3256              ; decode PRICE_DECIMALS
addr $$arg0 data_1            ; ptr to QUOTE_TOKEN default value
addi $$arg1 $zero i32         ; length of QUOTE_TOKEN default value
addi $$arg2 $ssp i8           ; ptr to global QUOTE_TOKEN stack address
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4
jmpf $zero i3361              ; decode QUOTE_TOKEN
addr $$arg0 data_2            ; ptr to QUOTE_TOKEN_DECIMALS default value
addi $$arg1 $zero i4          ; length of QUOTE_TOKEN_DECIMALS default value
addi $$arg2 $ssp i40          ; ptr to global QUOTE_TOKEN_DECIMALS stack address
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4
jmpf $zero i3242              ; decode QUOTE_TOKEN_DECIMALS
jmpf $zero i0                 ; jump to abi method selector
move $$locbase $sp            ; save locals base register for __entry
cfei i19208                   ; allocate 19208 bytes for locals and 0 slots for call arguments.
load $r5 data_4               ; get local constant
move $r0 $fp                  ; return value from inline asm (fp)
movi $r1 i592                 ; initialize constant into register
add  $r0 $r0 $r1
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3428              ; call read_17
move $r0 $$retv               ; copy the return value
sw   $$locbase $r0 i2117      ; store word
move $r0 $fp                  ; return value from inline asm (fp)
movi $r1 i584                 ; initialize constant into register
add  $r0 $r0 $r1
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3418              ; call read_17
move $r0 $$retv               ; copy the return value
sw   $$locbase $r0 i2215      ; store word
movi $r0 i17720               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3420              ; call read_8_bytes_21
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i32        ; get offset to local
movi $r3 i8                   ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $r1 i5         ; store word
movi $r3 i18952               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
lw   $r2 $r0 i0               ; load word
add  $r2 $r2 $r1
sw   $r0 $r2 i0               ; store word
movi $r0 i18952               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i7752                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3413              ; call ptr_23
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i16        ; get offset to local
sw   $$locbase $r0 i2         ; store word
sw   $$locbase $r1 i3         ; store word
movi $r0 i16944               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
movi $r0 i16944               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r5 i0         ; store word
movi $r1 i12                  ; initialize constant into register
sw   $$locbase $r1 i1         ; store word
addi $r1 $$locbase i872       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $$locbase $r2        ; copy memory with mem_copy
movi $r2 i14712               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i15448               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3399              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i339
load $r0 data_5               ; get local constant
load $r1 data_5               ; get local constant
load $r8 data_5               ; get local constant
load $r7 data_5               ; get local constant
load $r6 data_14              ; get local constant
load $r5 data_14              ; get local constant
movi $r2 i16936               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i4728                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3468              ; call decode_30
move $r2 $$retv               ; copy the return value
movi $r3 i17344               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r4 i17344               ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3482              ; call reentrancy_guard_33
addi $r2 $$locbase i320       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i44      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r0 i9744                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
movi $r1 i9816                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r4 $r2              ; copy memory with mem_copy
movi $r2 i6248                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9077              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i13648               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3720      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3725              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i18192               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18192               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i14456               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4762              ; call is_some_102
move $r0 $$retv               ; copy the return value
movi $r1 i14352               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
sw   $$locbase $one i1794     ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4405              ; call require_98
movi $r0 i18192               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i14728               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4488                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4753              ; call unwrap_103
move $r0 $$retv               ; copy the return value
movi $r1 i18448               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4760                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4763              ; call msg_sender_address_104
move $r0 $$retv               ; copy the return value
movi $r1 i18128               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18128               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i18448               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i32              ; get offset to element
movi $r2 i13440               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i13472               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3630              ; call eq_50
move $r0 $$retv               ; copy the return value
movi $r1 i14360               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
sw   $$locbase $zero i1795    ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4345              ; call require_98
movi $r0 i18448               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i15208               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5160                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5206              ; call cancel_order_internal_124
move $r0 $$retv               ; copy the return value
movi $r1 i16896               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i16896               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i17592               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r1 $$locbase i2116      ; load word
addi $r2 $$locbase i2536      ; get offset to local
sw   $$locbase $zero i317     ; store word
movi $r3 i18128               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
addi $r9 $r2 i8               ; get offset to element
movi $r10 i32                 ; get length for mcp
mcp  $r9 $r3 $r10             ; copy memory with mem_copy
movi $r3 i8872                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r9 i40                  ; get length for mcp
mcp  $r3 $r2 $r9              ; copy memory with mem_copy
movi $r2 i8912                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r2 $r0 $r9              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8529              ; call transfer_230
addi $r0 $$locbase i2744      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r8 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i347     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r7 $r2              ; copy memory with mem_copy
movi $r1 i9848                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i9920                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
movi $r2 i6320                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8907              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i13720               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3848      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3555              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i4904                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4701              ; call msg_sender_106
move $r1 $$retv               ; copy the return value
movi $r2 i14984               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i48                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i4824                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4666              ; call unwrap_105
move $r1 $$retv               ; copy the return value
bhei $r2                      ; bhei height
time $r2 $r2                  ; time timestamp height
move $r3 $zero                ; copy const asm init to GP reg
movi $r7 i6152                ; get offset to local
add  $r7 $$locbase $r7        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7991              ; call read_205
move $r3 $$retv               ; copy the return value
addi $r7 $$locbase i1408      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r7 $r4 $r8              ; copy memory with mem_copy
addi $r8 $r7 i32              ; get offset to element
movi $r9 i40                  ; get length for mcp
mcp  $r8 $r1 $r9              ; copy memory with mem_copy
sw   $$locbase $r2 i185       ; store word
sw   $$locbase $one i186      ; store word
addi $r1 $r7 i88              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r3 $r2              ; copy memory with mem_copy
addi $r1 $r7 i120             ; get offset to element
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2832      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i358     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r5 $r2              ; copy memory with mem_copy
movi $r1 i9952                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i10024               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
movi $r2 i6392                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8823              ; call get_250
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1408      ; get offset to local
movi $r2 i9088                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i9160                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i248                 ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8621              ; call push_244
addi $r0 $$locbase i1408      ; get offset to local
movi $r1 i10896               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8898              ; call log_253
move $r0 $zero                ; return value from inline asm (zero)
retd  $r0 $zero
load $r0 data_17              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2288      ; get offset to local
sw   $$locbase $r0 i286       ; store word
movi $r0 i13                  ; initialize constant into register
sw   $$locbase $r0 i287       ; store word
addi $r0 $$locbase i2520      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i16104               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i7800                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3032              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i34
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3336      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2930              ; call abi_decode_11
move $r1 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2820              ; call abi_decode_2
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i392       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
sw   $$locbase $r0 i53        ; store word
addi $r0 $$locbase i392       ; get offset to local
lw   $r1 $$locbase i53        ; load word
movi $r2 i12872               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i11144             ; call create_market
move $r0 $zero                ; return value from inline asm (zero)
retd  $r0 $zero
load $r0 data_18              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2728      ; get offset to local
sw   $$locbase $r0 i341       ; store word
movi $r0 i17                  ; initialize constant into register
sw   $$locbase $r0 i342       ; store word
addi $r0 $$locbase i2816      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i8304                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i8736                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2970              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i127
addi $r0 $ssp i8              ; configurable QUOTE_TOKEN address
addi $r1 $ssp i40             ; configurable QUOTE_TOKEN_DECIMALS address
addi $r2 $ssp i0              ; configurable PRICE_DECIMALS address
addi $r3 $$locbase i432       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $r3 i32              ; get offset to element
movi $r4 i8                   ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
addi $r0 $r3 i40              ; get offset to element
movi $r1 i8                   ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
movi $r0 i16960               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
movi $r0 i16960               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7024                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3246              ; call new_39
move $r1 $$retv               ; copy the return value
movi $r2 i11776               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r3 i11824               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
movi $r1 i7072                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9116              ; call abi_encode_258
move $r1 $$retv               ; copy the return value
lw   $r2 $r1 i0               ; load word
lw   $r3 $r1 i1               ; load word
lw   $r1 $r1 i2               ; load word
lw   $r4 $r0 i4               ; load word
movi $r5 i12128               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
sw   $$locbase $r2 i1516      ; store word
sw   $$locbase $r3 i1517      ; store word
sw   $$locbase $r1 i1518      ; store word
movi $r1 i7168                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9366              ; call abi_encode_278
move $r1 $$retv               ; copy the return value
lw   $r2 $r1 i0               ; load word
lw   $r3 $r1 i1               ; load word
lw   $r1 $r1 i2               ; load word
lw   $r0 $r0 i5               ; load word
movi $r4 i12152               ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
sw   $$locbase $r2 i1519      ; store word
sw   $$locbase $r3 i1520      ; store word
sw   $$locbase $r1 i1521      ; store word
movi $r1 i7192                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9347              ; call abi_encode_278
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
movi $r3 i13272               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i1659      ; store word
sw   $$locbase $r2 i1660      ; store word
sw   $$locbase $r0 i1661      ; store word
addi $r0 $$locbase i3576      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3199              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17008               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17008               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7768                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2838              ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17008               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12216               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9353              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
load $r0 data_19              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2904      ; get offset to local
sw   $$locbase $r0 i363       ; store word
movi $r0 i16                  ; initialize constant into register
sw   $$locbase $r0 i364       ; store word
addi $r0 $$locbase i2920      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i9480                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i10232               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2815              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i126
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7464                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10850             ; call abi_decode_362
move $r0 $$retv               ; copy the return value
movi $r1 i17376               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17376               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i12904               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i7560                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i11246             ; call get_market_by_id
move $r0 $$retv               ; copy the return value
movi $r1 i17024               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17024               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7288                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3073              ; call new_39
move $r1 $$retv               ; copy the return value
movi $r2 i11848               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r3 i11880               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
movi $r1 i7096                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8943              ; call abi_encode_258
move $r1 $$retv               ; copy the return value
lw   $r2 $r1 i0               ; load word
lw   $r3 $r1 i1               ; load word
lw   $r1 $r1 i2               ; load word
lw   $r0 $r0 i4               ; load word
movi $r4 i12176               ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
sw   $$locbase $r2 i1522      ; store word
sw   $$locbase $r3 i1523      ; store word
sw   $$locbase $r1 i1524      ; store word
movi $r1 i7216                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9193              ; call abi_encode_278
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
movi $r3 i13296               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i1662      ; store word
sw   $$locbase $r2 i1663      ; store word
sw   $$locbase $r0 i1664      ; store word
addi $r0 $$locbase i3592      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3045              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17064               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17064               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7784                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2684              ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17064               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12232               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9199              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
load $r0 data_20              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2936      ; get offset to local
sw   $$locbase $r0 i367       ; store word
movi $r0 i32                  ; initialize constant into register
sw   $$locbase $r0 i368       ; store word
addi $r0 $$locbase i3024      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i10808               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i11808               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2661              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i115
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i5128                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2742              ; call decode_30
move $r0 $$retv               ; copy the return value
movi $r1 i17408               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17408               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i12936               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i7600                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i11175             ; call get_order_change_events_by_order
move $r0 $$retv               ; copy the return value
movi $r1 i17080               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r8 i17080               ; get offset to local
add  $r8 $$locbase $r8        ; get offset to local
addi $r0 $$locbase i3432      ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2920              ; call new_39
move $r0 $$retv               ; copy the return value
movi $r1 i14240               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r8 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3498              ; call len_78
move $r9 $$retv               ; copy the return value
movi $r1 i13208               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6032                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r9               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2851              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r4 $r0 i0               ; load word
lw   $r5 $r0 i1               ; load word
lw   $r6 $r0 i2               ; load word
move $r7 $zero                ; parameter from branch to block argument
lt   $r0 $r7 $r9
jnzf $r0 $zero i2268
movi $r0 i13320               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r4 i1665      ; store word
sw   $$locbase $r5 i1666      ; store word
sw   $$locbase $r6 i1667      ; store word
addi $r1 $$locbase i3608      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2902              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17104               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17104               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i13048               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2541              ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17104               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12248               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9056              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
load $r0 data_6               ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i888       ; get offset to local
sw   $$locbase $r0 i111       ; store word
movi $r0 i13                  ; initialize constant into register
sw   $$locbase $r0 i112       ; store word
addi $r0 $$locbase i944       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i12200               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i12424               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2518              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i160
load $r0 data_7               ; get local constant
load $r1 data_7               ; get local constant
movi $r2 i16936               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i7496                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10549             ; call abi_decode_362
move $r2 $$retv               ; copy the return value
movi $r3 i17440               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r2 i17440               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r3 $$locbase i736       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
sw   $$locbase $zero i96      ; store word
addi $r0 $r3 i40              ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r0 i16408               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
movi $r1 i7816                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
movi $r2 i5672                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7100              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i16232               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r2 i5608                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7029              ; call slot_182
move $r1 $$retv               ; copy the return value
movi $r2 i14096               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3027              ; call offset_67
move $r0 $$retv               ; copy the return value
movi $r2 i15872               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i5400                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4621              ; call read_128
move $r0 $$retv               ; copy the return value
movi $r1 i12080               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8869              ; call is_none_271
move $r0 $$retv               ; copy the return value
eq   $r0 $r0 $zero
addi $r1 $$locbase i3480      ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2719              ; call new_39
move $r1 $$retv               ; copy the return value
movi $r2 i12056               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i7144                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8804              ; call abi_encode_265
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
movi $r3 i13344               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i1668      ; store word
sw   $$locbase $r2 i1669      ; store word
sw   $$locbase $r0 i1670      ; store word
addi $r0 $$locbase i3624      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2714              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17120               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17120               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i13232               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2353              ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17120               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12264               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8868              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
load $r0 data_8               ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2016      ; get offset to local
sw   $$locbase $r0 i252       ; store word
movi $r0 i12                  ; initialize constant into register
sw   $$locbase $r0 i253       ; store word
addi $r0 $$locbase i2104      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i12968               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i13064               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2330              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i47
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3400      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2253              ; call abi_decode_13
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i3656      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2245              ; call abi_decode_13
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i808       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $r2 i32              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i808       ; get offset to local
addi $r1 $$locbase i808       ; get offset to local
addi $r1 $r1 i32              ; get offset to element
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2415              ; call reentrancy_guard_33
movi $r2 i12328               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i12360               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8879              ; call match_orders_311
move $r0 $zero                ; return value from inline asm (zero)
retd  $r0 $zero
load $r0 data_9               ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2192      ; get offset to local
sw   $$locbase $r0 i274       ; store word
movi $r0 i17                  ; initialize constant into register
sw   $$locbase $r0 i275       ; store word
addi $r0 $$locbase i2208      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i13080               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i13096               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2255              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i270
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7240                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10028             ; call abi_decode_320
move $r1 $$retv               ; copy the return value
movi $r2 i7264                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10019             ; call abi_decode_320
move $r0 $$retv               ; copy the return value
lw   $r8 $r1 i0               ; load word
lw   $r7 $r1 i1               ; load word
lw   $r9 $r1 i2               ; load word
lw   $r6 $r0 i0               ; load word
lw   $r5 $r0 i1               ; load word
lw   $r10 $r0 i2              ; load word
movi $r0 i14264               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r8 i1783      ; store word
sw   $$locbase $r7 i1784      ; store word
sw   $$locbase $r9 i1785      ; store word
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3108              ; call len_78
move $r11 $$retv              ; copy the return value
movi $r0 i14288               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r6 i1786      ; store word
sw   $$locbase $r5 i1787      ; store word
sw   $$locbase $r10 i1788     ; store word
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3097              ; call len_78
move $r12 $$retv              ; copy the return value
gt   $r0 $r11 $zero
jnzf $r0 $zero i1
jmpf $zero i1
gt   $r0 $r12 $zero
movi $r1 i14368               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i3                   ; initialize constant into register
sw   $$locbase $r2 i1796      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3294              ; call require_98
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2305              ; call reentrancy_guard_33
move $r4 $zero                ; parameter from branch to block argument
move $r13 $zero               ; parameter from branch to block argument
load $r15 data_5              ; get local constant
load $r14 data_5              ; get local constant
movi $r0 i12472               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r8 i1559      ; store word
sw   $$locbase $r7 i1560      ; store word
sw   $$locbase $r9 i1561      ; store word
movi $r1 i7312                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r13              ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10081             ; call get_334
move $r0 $$retv               ; copy the return value
movi $r1 i8264                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6056                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6847              ; call unwrap_202
move $r0 $$retv               ; copy the return value
movi $r1 i18920               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i12496               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r6 i1562      ; store word
sw   $$locbase $r5 i1563      ; store word
sw   $$locbase $r10 i1564     ; store word
movi $r1 i7352                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10049             ; call get_334
move $r0 $$retv               ; copy the return value
movi $r1 i8320                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6088                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6815              ; call unwrap_202
move $r0 $$retv               ; copy the return value
movi $r1 i17688               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18920               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i17688               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12392               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i12440               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8695              ; call match_orders_311
addi $r0 $$locbase i1216      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r15 $r1             ; copy memory with mem_copy
sw   $$locbase $zero i156     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r14 $r2             ; copy memory with mem_copy
movi $r1 i18920               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i10056               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i10128               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i6464                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7810              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i13792               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3976      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2458              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i12544               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10020             ; call is_none_335
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i3
add  $r13 $r13 $one
eq   $r0 $r13 $r11
jnzf $r0 $zero i60
load $r0 data_5               ; get local constant
load $r1 data_5               ; get local constant
addi $r2 $$locbase i2336      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i296     ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r0 i17688               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i10160               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
movi $r2 i10248               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i6560                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7752              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i13864               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4104                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2399              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i12672               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9961              ; call is_none_335
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i3
add  $r4 $r4 $one
eq   $r0 $r4 $r12
jnzf $r0 $zero i1
jmpb $zero i198
move $r0 $zero                ; return value from inline asm (zero)
retd  $r0 $zero
load $r0 data_10              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2224      ; get offset to local
sw   $$locbase $r0 i278       ; store word
movi $r0 i10                  ; initialize constant into register
sw   $$locbase $r0 i279       ; store word
addi $r0 $$locbase i2240      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i13112               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i13128               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1957              ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i1303
load $r0 data_7               ; get local constant
load $r1 data_7               ; get local constant
movi $r2 i16936               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r3 $$locbase i3368      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1851              ; call abi_decode_11
move $r3 $$retv               ; copy the return value
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1903              ; call read_8_bytes_21
move $r4 $$retv               ; copy the return value
lw   $r5 $r2 i0               ; load word
lb   $r5 $r5 i0               ; lb val ptr i0
lw   $r6 $r2 i0               ; load word
add  $r6 $r6 $one
sw   $r2 $r6 i0               ; store word
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1892              ; call read_8_bytes_21
move $r2 $$retv               ; copy the return value
addi $r6 $$locbase i48        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r6 $r3 $r7              ; copy memory with mem_copy
addi $r3 $r6 i32              ; get offset to element
sw   $$locbase $r4 i10        ; store word
addi $r3 $r3 i8               ; get offset to element
sb   $r3 $r5 i0               ; store byte
sw   $$locbase $r2 i12        ; store word
movi $r2 i17472               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i56                  ; get length for mcp
mcp  $r2 $r6 $r3              ; copy memory with mem_copy
movi $r5 i17472               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r2 i17472               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r4 $r2 i32              ; get offset to element
movi $r2 i17472               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r10 $r2 i48             ; get offset to element
lw   $r6 $$locbase i2190      ; load word
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2017              ; call reentrancy_guard_33
addi $r2 $$locbase i104       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i17      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r0 i7848                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
movi $r1 i7920                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r5 $r2              ; copy memory with mem_copy
movi $r2 i5744                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6504              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i16304               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r2 i5640                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6433              ; call slot_182
move $r1 $$retv               ; copy the return value
movi $r2 i14168               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2431              ; call offset_67
move $r0 $$retv               ; copy the return value
movi $r2 i15904               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i5448                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4025              ; call read_128
move $r0 $$retv               ; copy the return value
movi $r1 i18040               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $r4 i0               ; load word
eq   $r0 $r0 $zero
eq   $r0 $r0 $zero
movi $r1 i14392               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i10                  ; initialize constant into register
sw   $$locbase $r2 i1799      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2923              ; call require_98
lw   $r0 $$locbase i2255      ; load word
eq   $r0 $r0 $one
move $r1 $one                 ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r1 $zero                ; parameter from branch to block argument
movi $r0 i14400               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i2                   ; initialize constant into register
sw   $$locbase $r2 i1800      ; store word
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2908              ; call require_98
eq   $r0 $r6 $zero
eq   $r0 $r0 $zero
movi $r1 i14408               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i9                   ; initialize constant into register
sw   $$locbase $r2 i1801      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2896              ; call require_98
movi $r0 i18040               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i15824               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5360                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3944              ; call unwrap_126
move $r0 $$retv               ; copy the return value
movi $r1 i18088               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $r4 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
jnzf $r0 $zero i63
move $r0 $bal                 ; return value from inline asm (bal)
lw   $r1 $r4 i0               ; load word
lw   $r2 $$locbase i2265      ; load word
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r6               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4168              ; call base_size_to_quote_amount_139
move $r1 $$retv               ; copy the return value
eq   $r0 $r0 $r1
movi $r1 i14432               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i8                   ; initialize constant into register
sw   $$locbase $r2 i1804      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2852              ; call require_98
addi $r0 $fp i32              ; addi asset_id fp i32
movi $r1 i15112               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5032                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3675              ; call from_118
move $r0 $$retv               ; copy the return value
addi $r1 $ssp i8              ; configurable QUOTE_TOKEN address
movi $r2 i13584               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i13616               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2098              ; call eq_50
move $r0 $$retv               ; copy the return value
movi $r1 i14440               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i7                   ; initialize constant into register
sw   $$locbase $r2 i1805      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2812              ; call require_98
jmpf $zero i52
move $r0 $bal                 ; return value from inline asm (bal)
lw   $r1 $r4 i0               ; load word
eq   $r0 $r0 $r1
movi $r1 i14416               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i8                   ; initialize constant into register
sw   $$locbase $r2 i1802      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2798              ; call require_98
addi $r0 $fp i32              ; addi asset_id fp i32
movi $r1 i15080               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5000                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3621              ; call from_118
move $r0 $$retv               ; copy the return value
movi $r1 i13520               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i13552               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r5 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2045              ; call eq_50
move $r0 $$retv               ; copy the return value
movi $r1 i14424               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i7                   ; initialize constant into register
sw   $$locbase $r2 i1803      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2759              ; call require_98
load $r0 data_5               ; get local constant
load $r1 data_5               ; get local constant
movi $r2 i4792                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3132              ; call msg_sender_address_104
move $r2 $$retv               ; copy the return value
movi $r3 i18160               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r3 $r2 $r6              ; copy memory with mem_copy
movi $r2 i18160               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r3 $$locbase i176       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r3 $r2 $r6              ; copy memory with mem_copy
addi $r2 $r3 i32              ; get offset to element
movi $r6 i32                  ; get length for mcp
mcp  $r2 $r5 $r6              ; copy memory with mem_copy
addi $r2 $r3 i64              ; get offset to element
movi $r6 i8                   ; get length for mcp
mcp  $r2 $r10 $r6             ; copy memory with mem_copy
movi $r2 i12800               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r6 i72                  ; get length for mcp
mcp  $r2 $r3 $r6              ; copy memory with mem_copy
movi $r3 i7432                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9601              ; call sha256_351
move $r2 $$retv               ; copy the return value
movi $r3 i18808               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r3 $r2 $r6              ; copy memory with mem_copy
addi $r2 $$locbase i2952      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i373     ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r0 i18808               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i10280               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
movi $r2 i10352               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i6632                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7323              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i13936               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4232                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1970              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i18320               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18320               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i14584               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3007              ; call is_some_102
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i315
load $r0 data_5               ; get local constant
load $r1 data_5               ; get local constant
load $r14 data_12             ; get local constant
load $r13 data_12             ; get local constant
load $r9 data_13              ; get local constant
load $r8 data_13              ; get local constant
load $r7 data_12              ; get local constant
load $r6 data_12              ; get local constant
movi $r2 i18808               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i18160               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
addi $r11 $$locbase i1288     ; get offset to local
movi $r12 i32                 ; get length for mcp
mcp  $r11 $r2 $r12            ; copy memory with mem_copy
addi $r2 $r11 i32             ; get offset to element
movi $r12 i32                 ; get length for mcp
mcp  $r2 $r3 $r12             ; copy memory with mem_copy
addi $r2 $r11 i64             ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r5 $r3              ; copy memory with mem_copy
addi $r2 $r11 i96             ; get offset to element
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r4 $r3              ; copy memory with mem_copy
addi $r2 $r11 i112            ; get offset to element
movi $r3 i8                   ; get length for mcp
mcp  $r2 $r10 $r3             ; copy memory with mem_copy
movi $r2 i18688               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i120                 ; get length for mcp
mcp  $r2 $r11 $r3             ; copy memory with mem_copy
movi $r5 i18688               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
addi $r2 $$locbase i248       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i35      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i8632                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r0 i72                  ; get length for mcp
mcp  $r1 $r2 $r0              ; copy memory with mem_copy
movi $r2 i8704                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r0 i32                  ; get length for mcp
mcp  $r2 $r5 $r0              ; copy memory with mem_copy
movi $r3 i8752                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r0 i120                 ; get length for mcp
mcp  $r3 $r5 $r0              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6739              ; call insert_227
addi $r0 $$locbase i1696      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r14 $r1             ; copy memory with mem_copy
sw   $$locbase $zero i216     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r13 $r2             ; copy memory with mem_copy
addi $r1 $r5 i32              ; get offset to element
movi $r2 i7952                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i8024                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i5816                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6092              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i10592               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r2 i6848                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7251              ; call field_id_251
move $r1 $$retv               ; copy the return value
movi $r2 i16168               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i5576                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5868              ; call read_180
move $r1 $$retv               ; copy the return value
movi $r2 i16376               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6030              ; call unwrap_or_196
move $r1 $$retv               ; copy the return value
movi $r2 i10664               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r3 i6880                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7213              ; call field_id_251
move $r2 $$retv               ; copy the return value
movi $r3 i8400                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r2 i6216                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6292              ; call sha256_211
move $r2 $$retv               ; copy the return value
movi $r3 i18008               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6328              ; call offset_calculator_212
move $r2 $$retv               ; copy the return value
movi $r3 i18008               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i8432                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r10 i32                 ; get length for mcp
mcp  $r4 $r3 $r10             ; copy memory with mem_copy
movi $r3 i8464                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r10 i32                 ; get length for mcp
mcp  $r3 $r5 $r10             ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6445              ; call write_218
movi $r2 i10736               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i6912                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7160              ; call field_id_251
move $r0 $$retv               ; copy the return value
add  $r1 $r1 $one
movi $r2 i8496                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6494              ; call write_220
addi $r0 $$locbase i2448      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r9 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i310     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r8 $r2              ; copy memory with mem_copy
addi $r1 $r5 i32              ; get offset to element
movi $r2 i8056                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i8128                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i5888                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5950              ; call get_198
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2656      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r7 $r2              ; copy memory with mem_copy
sw   $$locbase $zero i336     ; store word
addi $r2 $r1 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r6 $r3              ; copy memory with mem_copy
addi $r2 $r5 i32              ; get offset to element
movi $r3 i8160                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i72                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
movi $r1 i8232                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r2 $r4              ; copy memory with mem_copy
movi $r2 i5960                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5924              ; call get_198
move $r1 $$retv               ; copy the return value
movi $r2 i10824               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i6944                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7083              ; call field_id_251
move $r1 $$retv               ; copy the return value
movi $r2 i16200               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i5592                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5700              ; call read_180
move $r1 $$retv               ; copy the return value
movi $r2 i16392               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5862              ; call unwrap_or_196
move $r1 $$retv               ; copy the return value
movi $r2 i8528                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i8600                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r5 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6437              ; call insert_222
jmpf $zero i363
load $r0 data_11              ; get local constant
movi $r1 i18320               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i14856               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i128                 ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i4608                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2689              ; call unwrap_103
move $r1 $$retv               ; copy the return value
movi $r2 i18568               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i120                 ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r5 i18568               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
lw   $r1 $$locbase i2333      ; load word
eq   $r1 $r1 $zero
eq   $r1 $r1 $zero
movi $r2 i14448               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i10                  ; initialize constant into register
sw   $$locbase $r3 i1806      ; store word
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2307              ; call require_98
movi $r1 i15144               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r2 i5064                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3131              ; call from_118
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i1656      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i211     ; store word
movi $r1 i15176               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
movi $r0 i5096                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3114              ; call from_118
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2408      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i305     ; store word
addi $r0 $$locbase i2576      ; get offset to local
movi $r3 i40                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
addi $r2 $r0 i40              ; get offset to element
movi $r3 i40                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i18840               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i80                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $r5 i96              ; get offset to element
movi $r1 i16120               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r4 $r2              ; copy memory with mem_copy
movi $r2 i5496                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5445              ; call flip_172
move $r1 $$retv               ; copy the return value
movi $r2 i16072               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i16088               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5409              ; call eq_171
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i104
addi $r0 $r5 i96              ; get offset to element
addi $r1 $r0 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
jnzf $r1 $zero i1
jmpf $zero i2
addi $r1 $r4 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
jnzf $r1 $zero i8
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
eq   $r1 $r0 $zero
jnzf $r1 $zero i1
jmpf $zero i3
addi $r0 $r4 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
eq   $r1 $r0 $zero
eq   $r0 $r1 $zero
jnzf $r0 $zero i1
jmpf $zero i70
movi $r0 i19088               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i120                 ; get length for mcp
mcp  $r0 $r5 $r1              ; copy memory with mem_copy
lw   $r0 $r5 i12              ; load word
lw   $r1 $r4 i0               ; load word
lt   $r2 $r0 $r1
jnzf $r2 $zero i1
move $r0 $r1                  ; parameter from branch to block argument
sw   $$locbase $r0 i2398      ; store word
movi $r0 i19088               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i15584               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5280                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3130              ; call order_return_asset_amount_125
move $r0 $$retv               ; copy the return value
movi $r1 i18840               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i19088               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i96              ; get offset to element
movi $r1 i16152               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5560                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5365              ; call flip_172
move $r0 $$retv               ; copy the return value
movi $r1 i19088               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i19088               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i15704               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5320                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3090              ; call order_return_asset_amount_125
move $r0 $$retv               ; copy the return value
movi $r1 i18840               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i40              ; get offset to element
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i15936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i120                 ; get length for mcp
mcp  $r0 $r5 $r1              ; copy memory with mem_copy
movi $r1 i16056               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r4 $r2              ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4109              ; call remove_update_order_internal_170
jmpf $zero i62
movi $r0 i18968               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i120                 ; get length for mcp
mcp  $r0 $r5 $r1              ; copy memory with mem_copy
movi $r0 i15328               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i120                 ; get length for mcp
mcp  $r0 $r5 $r1              ; copy memory with mem_copy
movi $r1 i5200                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2988              ; call cancel_order_internal_124
move $r0 $$retv               ; copy the return value
movi $r1 i18840               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18968               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i96              ; get offset to element
movi $r1 i16136               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5512                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5288              ; call flip_172
move $r0 $$retv               ; copy the return value
movi $r1 i18968               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18968               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i15464               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5240                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i3013              ; call order_return_asset_amount_125
move $r0 $$retv               ; copy the return value
movi $r1 i18840               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i40              ; get offset to element
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i18840               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i16736               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i80                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i16816               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i18840               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
movi $r0 i16816               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i17624               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i2106      ; load word
movi $r1 i16856               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i18840               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r2 $r2 i40              ; get offset to element
movi $r3 i40                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
movi $r1 i16856               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i17656               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
lw   $r1 $$locbase i2111      ; load word
gt   $r2 $r0 $zero
jnzf $r2 $zero i1
jmpf $zero i24
addi $r2 $$locbase i3040      ; get offset to local
sw   $$locbase $zero i380     ; store word
movi $r3 i18160               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
addi $r4 $r2 i8               ; get offset to element
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i17624               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i8944                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i40                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
movi $r2 i8984                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r2 $r3 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6239              ; call transfer_230
gt   $r0 $r1 $zero
jnzf $r0 $zero i1
jmpf $zero i24
addi $r0 $$locbase i904       ; get offset to local
sw   $$locbase $zero i113     ; store word
movi $r2 i18160               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r3 $r0 i8               ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r2 i17656               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i9016                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i40                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
movi $r0 i9056                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r0 $r2 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6212              ; call transfer_230
load $r0 data_5               ; get local constant
load $r1 data_5               ; get local constant
load $r8 data_14              ; get local constant
load $r7 data_14              ; get local constant
movi $r2 i18808               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r3 $$locbase i2032      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
sw   $$locbase $zero i258     ; store word
addi $r0 $r3 i40              ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r0 i18808               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i10384               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r4 i72                  ; get length for mcp
mcp  $r1 $r3 $r4              ; copy memory with mem_copy
movi $r3 i10456               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
movi $r0 i6704                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6578              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i14008               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4360                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1225              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i4952                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2371              ; call msg_sender_106
move $r1 $$retv               ; copy the return value
movi $r3 i15032               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
movi $r1 i4864                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2336              ; call unwrap_105
move $r1 $$retv               ; copy the return value
bhei $r3                      ; bhei height
time $r3 $r3                  ; time timestamp height
move $r4 $zero                ; copy const asm init to GP reg
movi $r5 i6184                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5661              ; call read_205
move $r4 $$retv               ; copy the return value
addi $r5 $$locbase i1768      ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r2 $r6              ; copy memory with mem_copy
addi $r2 $r5 i32              ; get offset to element
movi $r6 i40                  ; get length for mcp
mcp  $r2 $r1 $r6              ; copy memory with mem_copy
sw   $$locbase $r3 i230       ; store word
sw   $$locbase $zero i231     ; store word
addi $r1 $r5 i88              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r4 $r2              ; copy memory with mem_copy
addi $r1 $r5 i120             ; get offset to element
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2120      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r8 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i269     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r7 $r2              ; copy memory with mem_copy
movi $r1 i18808               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i10488               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i10560               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i6776                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6491              ; call get_250
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1768      ; get offset to local
movi $r2 i9408                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i9496                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i248                 ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6289              ; call push_244
addi $r0 $$locbase i1768      ; get offset to local
movi $r1 i11144               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6566              ; call log_253
movi $r0 i18808               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i17136               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i3504      ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1019              ; call new_39
move $r1 $$retv               ; copy the return value
movi $r2 i11664               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i11696               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i7000                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6840              ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
movi $r3 i13368               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i1671      ; store word
sw   $$locbase $r2 i1672      ; store word
sw   $$locbase $r0 i1673      ; store word
addi $r0 $$locbase i3640      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1010              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17168               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17168               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i13504               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i649               ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17168               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12280               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7164              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
load $r0 data_15              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2256      ; get offset to local
sw   $$locbase $r0 i282       ; store word
movi $r0 i11                  ; initialize constant into register
sw   $$locbase $r0 i283       ; store word
addi $r0 $$locbase i2272      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i13144               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i13160               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i626               ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i106
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i5528                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i707               ; call decode_30
move $r0 $$retv               ; copy the return value
movi $r1 i17528               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17528               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i12984               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i7624                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9277              ; call order_by_id
move $r0 $$retv               ; copy the return value
movi $r1 i17184               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17184               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3528      ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i885               ; call new_39
move $r1 $$retv               ; copy the return value
movi $r2 i11904               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i128                 ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i12032               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r1 i7120                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6789              ; call abi_encode_261
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
movi $r3 i13392               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i1674      ; store word
sw   $$locbase $r2 i1675      ; store word
sw   $$locbase $r0 i1676      ; store word
addi $r0 $$locbase i3688      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i876               ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17312               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17312               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i14080               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i515               ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17312               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12296               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7030              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
load $r0 data_16              ; get local constant
movi $r1 i16944               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i2304      ; get offset to local
sw   $$locbase $r0 i288       ; store word
movi $r0 i16                  ; initialize constant into register
sw   $$locbase $r0 i289       ; store word
addi $r0 $$locbase i2320      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
movi $r2 i13176               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i13192               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i492               ; call eq_25
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i112
movi $r0 i16936               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7528                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8527              ; call abi_decode_362
move $r0 $$retv               ; copy the return value
movi $r1 i17560               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17560               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i13016               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3456      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9195              ; call orders_by_trader
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i3552      ; get offset to local
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i755               ; call new_39
move $r3 $$retv               ; copy the return value
movi $r4 i14312               ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
sw   $$locbase $r1 i1789      ; store word
sw   $$locbase $r2 i1790      ; store word
sw   $$locbase $r0 i1791      ; store word
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1332              ; call len_78
move $r4 $$retv               ; copy the return value
movi $r5 i13248               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r6 i24                  ; get length for mcp
mcp  $r5 $r3 $r6              ; copy memory with mem_copy
movi $r3 i6536                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i685               ; call abi_encode_38
move $r3 $$retv               ; copy the return value
lw   $r7 $r3 i0               ; load word
lw   $r8 $r3 i1               ; load word
lw   $r9 $r3 i2               ; load word
move $r10 $zero               ; parameter from branch to block argument
lt   $r3 $r10 $r4
jnzf $r3 $zero i44
movi $r0 i13416               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r7 i1677      ; store word
sw   $$locbase $r8 i1678      ; store word
sw   $$locbase $r9 i1679      ; store word
addi $r1 $$locbase i3704      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i736               ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i17328               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i17328               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i14376               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i375               ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i17328               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12312               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6890              ; call len_282
move $r1 $$retv               ; copy the return value
retd  $r0 $r1
movi $r0 i123                 ; initialize constant into register
rvrt $r0
movi $r3 i12520               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i1565      ; store word
sw   $$locbase $r2 i1566      ; store word
sw   $$locbase $r0 i1567      ; store word
movi $r5 i7392                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r10              ; pass arg 1
move $$arg2 $r5               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8276              ; call get_334
move $r3 $$retv               ; copy the return value
movi $r5 i8360                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r6 i40                  ; get length for mcp
mcp  $r5 $r3 $r6              ; copy memory with mem_copy
movi $r3 i6120                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5042              ; call unwrap_202
move $r3 $$retv               ; copy the return value
movi $r5 i17976               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r3 $r6              ; copy memory with mem_copy
movi $r3 i17976               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i11720               ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r3 $r6              ; copy memory with mem_copy
movi $r3 i11752               ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r7 i1469      ; store word
sw   $$locbase $r8 i1470      ; store word
sw   $$locbase $r9 i1471      ; store word
movi $r6 i7048                ; get offset to local
add  $r6 $$locbase $r6        ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r6               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6466              ; call abi_encode_256
move $r3 $$retv               ; copy the return value
lw   $r7 $r3 i0               ; load word
lw   $r8 $r3 i1               ; load word
lw   $r9 $r3 i2               ; load word
add  $r10 $r10 $one
jmpb $zero i102
lw   $r0 $r8 i2               ; load word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i5190              ; call le_210
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i23
movi $r0 i14336               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r8 $r1              ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1242              ; call ptr_87
move $r0 $$retv               ; copy the return value
movi $r1 i248                 ; initialize constant into register
mul  $r1 $r1 $r7
add  $r0 $r0 $r1
addi $r1 $$locbase i960       ; get offset to local
sw   $$locbase $one i120      ; store word
addi $r2 $r1 i8               ; get offset to element
movi $r3 i248                 ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r2 i16480               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r0 i256                 ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i6
addi $r0 $$locbase i480       ; get offset to local
sw   $$locbase $zero i60      ; store word
movi $r2 i16480               ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r1 i256                 ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
addi $r0 $$locbase i3080      ; get offset to local
movi $r1 i256                 ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
lw   $r0 $$locbase i2060      ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i3080      ; get offset to local
addi $r0 $r0 i8               ; get offset to element
movi $r1 i17728               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r1 i11392               ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i11640               ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r4 i1455      ; store word
sw   $$locbase $r5 i1456      ; store word
sw   $$locbase $r6 i1457      ; store word
movi $r2 i6976                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6142              ; call abi_encode_255
move $r0 $$retv               ; copy the return value
lw   $r4 $r0 i0               ; load word
lw   $r5 $r0 i1               ; load word
lw   $r6 $r0 i2               ; load word
add  $r7 $r7 $one
jmpb $zero i2343
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_in_place_0
cfei i24                      ; allocate 24 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg1               ; save arg 1 (len)
move $r2 $$arg2               ; save arg 2 (target)
move $r3 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i21                ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i8         ; get offset to local
movi $r4 i8                   ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i8         ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i23                ; call abi_decode_2
move $r0 $$retv               ; copy the return value
sw   $$locbase $r0 i2         ; store word
addi $r0 $$locbase i16        ; get offset to local
movi $r1 i8                   ; initialize constant into register
mcp  $r2 $r0 $r1              ; mcp target temp size
move $$retv $zero             ; set return value
cfsi i24                      ; free 24 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_parts_1
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg2               ; save arg 2 (__ret_value)
move $r2 $$reta               ; save reta
sw   $r1 $r0 i0               ; store word
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_2
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i39                ; call read_4
move $r2 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i33                ; call read_4
move $r3 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i27                ; call read_4
move $r4 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i21                ; call read_4
move $r0 $$retv               ; copy the return value
movi $r5 i24                  ; initialize constant into register
sll  $r2 $r2 $r5
load $r5 data_3               ; literal instantiation
and  $r2 $r2 $r5
movi $r5 i16                  ; initialize constant into register
sll  $r3 $r3 $r5
load $r5 data_3               ; literal instantiation
and  $r3 $r3 $r5
or   $r2 $r2 $r3
movi $r3 i8                   ; initialize constant into register
sll  $r3 $r4 $r3
load $r4 data_3               ; literal instantiation
and  $r3 $r3 $r4
or   $r2 $r2 $r3
or   $r0 $r2 $r0
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_4
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r2 $r0 i0               ; load word
lb   $r2 $r2 i0               ; lb val ptr i0
lw   $r3 $r0 i0               ; load word
add  $r3 $r3 $one
sw   $r0 $r3 i0               ; store word
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_in_place_10
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg1               ; save arg 1 (len)
move $r2 $$arg2               ; save arg 2 (target)
move $r3 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i89                ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i40        ; get offset to local
movi $r4 i8                   ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i40        ; get offset to local
addi $r1 $$locbase i8         ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i13                ; call abi_decode_11
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i48        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i48        ; get offset to local
movi $r1 i32                  ; initialize constant into register
mcp  $r2 $r0 $r1              ; mcp target temp size
move $$retv $zero             ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_11
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i32        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i11                ; call abi_decode_13
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_13
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r3 $r4        ; copy memory with mem_copy
lw   $r3 $r0 i0               ; load word
movi $r4 i32                  ; initialize constant into register
add  $r3 $r3 $r4
sw   $r0 $r3 i0               ; store word
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_17
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; lw val ptr i0
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_8_bytes_21
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r2 $r0 i0               ; load word
lw   $r2 $r2 i0               ; lw val ptr i0
lw   $r3 $r0 i0               ; load word
movi $r4 i8                   ; initialize constant into register
add  $r3 $r3 $r4
sw   $r0 $r3 i0               ; store word
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_23
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for eq_25
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
movi $r3 i16                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i48                ; call len_28
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i16        ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i39                ; call len_28
move $r4 $$retv               ; copy the return value
eq   $r3 $r3 $r4
eq   $r3 $r3 $zero
move $r4 $zero                ; parameter from branch to block argument
jnzf $r3 $zero i28
addi $r3 $$locbase i48        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i42                ; call as_ptr_29
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i64        ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i33                ; call as_ptr_29
move $r1 $$retv               ; copy the return value
addi $r4 $$locbase i32        ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8                 ; call len_28
move $r0 $$retv               ; copy the return value
meq  $r4 $r3 $r1 $r0          ; meq r4 r1 r2 r3
move $$retv $r4               ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for len_28
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i1               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for as_ptr_29
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for decode_30
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i32        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i171               ; call abi_decode_13
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for reentrancy_guard_33
cfei i384                     ; allocate 384 bytes for locals and 0 slots for call arguments.
move $r0 $$reta               ; save reta
move $r1 $fp                  ; return value from inline asm (fp)
addi $r2 $$locbase i256       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i80        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1805              ; call from_118
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i352       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $r5 $fp                  ; return value from inline asm (fp)
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i211               ; call is_null_46
move $r1 $$retv               ; copy the return value
eq   $r1 $r1 $zero
jnzf $r1 $zero i1
jmpf $zero i6
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i214               ; call get_previous_frame_pointer_47
move $r5 $$retv               ; copy the return value
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i196               ; call is_null_46
move $r1 $$retv               ; copy the return value
eq   $r1 $r1 $zero
move $r2 $zero                ; parameter from branch to block argument
jnzf $r1 $zero i1
jmpf $zero i38
addi $r1 $$locbase i288       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r5 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i112       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1765              ; call from_118
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i320       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i320       ; get offset to local
addi $r2 $$locbase i352       ; get offset to local
addi $r3 $$locbase i192       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
addi $r1 $$locbase i224       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r2 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i186               ; call eq_50
move $r1 $$retv               ; copy the return value
move $r2 $one                 ; parameter from branch to block argument
jnzf $r1 $zero i7
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i167               ; call get_previous_frame_pointer_47
move $r5 $$retv               ; copy the return value
jmpb $zero i46
eq   $r1 $r2 $zero
eq   $r1 $r1 $zero
jnzf $r1 $zero i2
move $$retv $zero             ; set return value
jmpf $zero i46
addi $r0 $$locbase i40        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i90                ; call new_39
move $r0 $$retv               ; copy the return value
eq   $r1 $zero $zero
jnzf $r1 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r1 $$locbase i144       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i16        ; get offset to local
move $$arg0 $zero             ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i29                ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i168       ; get offset to local
sw   $$locbase $r1 i21        ; store word
sw   $$locbase $r2 i22        ; store word
sw   $$locbase $r0 i23        ; store word
addi $r0 $$locbase i64        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i84                ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $$locbase $r0 $r1        ; copy memory with mem_copy
load $r0 data_22              ; literal instantiation
lw   $r1 $$locbase i0         ; load slice ptr
lw   $r2 $$locbase i1         ; load slice size
logd $zero $r0 $r1 $r2        ; log slice
load $r0 data_23              ; literal instantiation
rvrt $r0
cfsi i384                     ; free 384 bytes for locals and 0 slots for extra call arguments.
move $$reta $r0               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_38
cfei i96                      ; allocate 96 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i72        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i8                   ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
add  $r4 $r6 $r1
sw   $r4 $r0 i0               ; store word
movi $r0 i8                   ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i24        ; get offset to local
sw   $$locbase $r6 i3         ; store word
sw   $$locbase $r5 i4         ; store word
sw   $$locbase $r0 i5         ; store word
addi $r0 $$locbase i48        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i96                      ; free 96 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_39
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
movi $r2 i1024                ; initialize constant into register
aloc $r2
move $r2 $hp                  ; return value from inline asm (hp)
sw   $$locbase $r2 i0         ; store word
movi $r2 i1024                ; initialize constant into register
sw   $$locbase $r2 i1         ; store word
sw   $$locbase $zero i2       ; store word
move $r2 $$locbase            ; copy const asm init to GP reg
addi $r3 $$locbase i24        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r3 $r2              ; copy memory with mem_copy
move $$retv $r0               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for as_raw_slice_40
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i40        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
movi $r0 i24                  ; get length for mcp
mcp  $$locbase $r3 $r0        ; copy memory with mem_copy
lw   $r0 $$locbase i0         ; load word
addi $r3 $$locbase i16        ; get offset to element
addi $r4 $$locbase i24        ; get offset to local
sw   $$locbase $r0 i3         ; store word
addi $r0 $r4 i8               ; get offset to element
movi $r5 i8                   ; get length for mcp
mcp  $r0 $r3 $r5              ; copy memory with mem_copy
movi $r0 i16                  ; get length for mcp
mcp  $r1 $r4 $r0              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for is_null_46
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
move $r2 $zero                ; return value from inline asm (zero)
eq   $r0 $r0 $r2
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for get_previous_frame_pointer_47
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (frame_pointer)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i14              ; lw res ptr i0
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for eq_50
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
addi $r0 $$locbase i32        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
wqcm $r0 $$locbase $r0 i32
move $$retv $r0               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for try_read_52
cfei i720                     ; allocate 720 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r5 $$arg1               ; save arg 1 (__ret_value)
move $r4 $$reta               ; save reta
addi $r1 $$locbase i440       ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i304       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i4157              ; call slot_182
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i368       ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i156               ; call offset_67
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i336       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i256       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i43                ; call slot_calculator_54
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i640       ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i640       ; get offset to local
addi $r1 $$locbase i688       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i84        ; load word
lw   $r1 $$locbase i85        ; load word
movi $r2 i32                  ; initialize constant into register
mul  $r2 $r0 $r2
movi $r3 i8                   ; initialize constant into register
mul  $r2 $r3 $r2
aloc $r2                      ; aloc size
move $r2 $hp                  ; move ptr hp
addi $r3 $$locbase i688       ; get offset to local
srwq $r2 $r0 $r3 $r0          ; access a sequence of storage slots
jnzf $r0 $zero i6
addi $r0 $$locbase i128       ; get offset to local
sw   $$locbase $zero i16      ; store word
addi $r2 $$locbase i512       ; get offset to local
movi $r1 i128                 ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i10
sw   $$locbase $one i0        ; store word
movi $r0 i8                   ; initialize constant into register
mul  $r0 $r0 $r1
add  $r0 $r2 $r0
addi $r1 $$locbase i8         ; get offset to element
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i512       ; get offset to local
movi $r0 i128                 ; get length for mcp
mcp  $r2 $$locbase $r0        ; copy memory with mem_copy
movi $r0 i128                 ; get length for mcp
mcp  $r5 $r2 $r0              ; copy memory with mem_copy
move $$retv $r5               ; set return value
cfsi i720                     ; free 720 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for slot_calculator_54
cfei i368                     ; allocate 368 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r8 $$arg2               ; save arg 2 (__ret_value)
move $r7 $$reta               ; save reta
movi $r2 i8                   ; initialize constant into register
mul  $r2 $r1 $r2
movi $r3 i120                 ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i31                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i4                   ; initialize constant into register
mod  $r1 $r1 $r3
movi $r3 i8                   ; initialize constant into register
mul  $r3 $r1 $r3
movi $r4 i120                 ; initialize constant into register
add  $r3 $r3 $r4
movi $r4 i31                  ; initialize constant into register
add  $r3 $r3 $r4
movi $r4 i5                   ; initialize constant into register
srl  $r3 $r3 $r4
addi $r4 $$locbase i48        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r4 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
addi $r4 $$locbase i112       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i41                ; call as_u256_62
move $r2 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i33                ; call as_u256_62
move $r4 $$retv               ; copy the return value
addi $r5 $$locbase i176       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r2 $r6              ; copy memory with mem_copy
addi $r2 $$locbase i304       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r2 $r4 $r6              ; copy memory with mem_copy
addi $r4 $$locbase i240       ; get offset to local
wqop $r4 $r5 $r2 i33
addi $r2 $$locbase i208       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i240       ; get offset to local
addi $r4 $$locbase i272       ; get offset to local
wqop $r4 $r2 $r0 i32
addi $r0 $$locbase i336       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i80        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
sw   $$locbase $r3 i4         ; store word
sw   $$locbase $r1 i5         ; store word
movi $r0 i48                  ; get length for mcp
mcp  $r8 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r8               ; set return value
cfsi i368                     ; free 368 bytes for locals and 0 slots for extra call arguments.
move $$reta $r7               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for as_u256_62
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
sw   $$locbase $zero i0       ; store word
sw   $$locbase $zero i1       ; store word
sw   $$locbase $zero i2       ; store word
sw   $$locbase $r0 i3         ; store word
move $r0 $$locbase            ; copy const asm init to GP reg
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for offset_67
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i4               ; load word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for sha256_69
cfei i168                     ; allocate 168 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (s)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i34                ; call new_70
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i144       ; get offset to local
addi $r4 $$locbase i56        ; get offset to local
movi $r5 i64                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i58                ; call hash_74
addi $r0 $$locbase i144       ; get offset to local
addi $r3 $$locbase i120       ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i437               ; call sha256_94
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i168                     ; free 168 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_70
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i12                ; call new_72
move $r2 $$retv               ; copy the return value
lw   $r3 $r2 i0               ; load word
lw   $r2 $r2 i1               ; load word
sw   $r0 $r3 i0               ; store word
sw   $r0 $r2 i1               ; store word
sw   $r0 $zero i2             ; store word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_72
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
move $r2 $zero                ; copy const asm init to GP reg
aloc $r2                      ; aloc size
move $r2 $hp                  ; return value from inline asm (hp)
sw   $r0 $r2 i0               ; store word
sw   $r0 $zero i1             ; store word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for hash_74
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (state)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i16                ; call hash_75
addi $r0 $r0 i32              ; get offset to element
addi $r3 $$locbase i32        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6                 ; call hash_75
move $$retv $zero             ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for hash_75
cfei i112                     ; allocate 112 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (state)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; initialize constant into register
aloc $r3                      ; aloc size
move $r3 $hp                  ; return value from inline asm (hp)
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r0 $r4        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r4 $r0 i0               ; load word
lw   $r5 $r0 i1               ; load word
lw   $r6 $r0 i2               ; load word
lw   $r0 $r0 i3               ; load word
sw   $r3 $r4 i0               ; sw ptr val_1 i0
sw   $r3 $r5 i1               ; sw ptr val_2 i1
sw   $r3 $r6 i2               ; sw ptr val_3 i2
sw   $r3 $r0 i3               ; sw ptr val_4 i3
addi $r0 $$locbase i32        ; get offset to local
move $$arg0 $r3               ; pass arg 0
movi $r3 i32                  ; initialize constant into register
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i188               ; call from_parts_82
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i96        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i48        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i281               ; call from_93
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i72        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i6                 ; call write_76
move $$retv $zero             ; set return value
cfsi i112                     ; free 112 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i1023                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for write_76
cfei i176                     ; allocate 176 bytes for locals and 0 slots for call arguments.
move $r8 $$arg0               ; save arg 0 (self)
move $r7 $$arg1               ; save arg 1 (bytes)
move $r6 $$reta               ; save reta
addi $r0 $$locbase i32        ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r7 $r1              ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i114               ; call len_78
move $r9 $$retv               ; copy the return value
eq   $r0 $r9 $zero
jnzf $r0 $zero i105
lw   $r0 $r8 i2               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i95
lw   $r0 $r8 i2               ; load word
add  $r0 $r0 $r9
lw   $r1 $r8 i2               ; load word
addi $r2 $$locbase i128       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r8 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7094              ; call capacity_326
move $r2 $$retv               ; copy the return value
lt   $r2 $r2 $r0
jnzf $r2 $zero i1
jmpf $zero i53
addi $r2 $$locbase i56        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r8 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i136               ; call ptr_87
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i144       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r8 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i7073              ; call capacity_326
move $r3 $$retv               ; copy the return value
gt   $r4 $r0 $r3
jnzf $r4 $zero i1
jmpf $zero i7
aloc $r0                      ; aloc size
move $r4 $hp                  ; return value from inline asm (hp)
gt   $r5 $r3 $zero
jnzf $r5 $zero i1
jmpf $zero i1
mcp  $r4 $r2 $r3              ; mcp dst src len
move $r2 $r4                  ; parameter from branch to block argument
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i90                ; call from_parts_82
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i160       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i160       ; get offset to local
addi $r3 $$locbase i88        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i16        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i105               ; call from_88
move $r2 $$retv               ; copy the return value
movi $r3 i16                  ; get length for mcp
mcp  $r8 $r2 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i72        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r8 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i83                ; call ptr_87
move $r2 $$retv               ; copy the return value
add  $r1 $r2 $r1              ; add new ptr offset
addi $r2 $$locbase i104       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r7 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i138               ; call ptr_92
move $r2 $$retv               ; copy the return value
mcp  $r1 $r2 $r9              ; mcp dst src len
sw   $r8 $r0 i2               ; store word
move $$arg0 $r7               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i25                ; call clear_79
jmpf $zero i7
movi $r0 i24                  ; get length for mcp
mcp  $r8 $r7 $r0              ; copy memory with mem_copy
move $$arg0 $r7               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i17                ; call clear_79
move $$retv $zero             ; set return value
cfsi i176                     ; free 176 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i1023                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for len_78
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i2               ; load word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for clear_79
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i252               ; call new_72
move $r2 $$retv               ; copy the return value
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
sw   $r0 $zero i2             ; store word
move $$retv $zero             ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_parts_82
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg1               ; save arg 1 (count)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
sw   $$locbase $r0 i0         ; store word
sw   $$locbase $r1 i1         ; store word
move $r0 $$locbase            ; copy const asm init to GP reg
movi $r1 i16                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_87
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_88
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slice)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i16        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i23                ; call number_of_bytes_89
move $r3 $$retv               ; copy the return value
aloc $r3                      ; aloc size
move $r4 $hp                  ; return value from inline asm (hp)
gt   $r5 $r3 $zero
jnzf $r5 $zero i1
jmpf $zero i9
movi $r5 i16                  ; get length for mcp
mcp  $$locbase $r0 $r5        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i996               ; call ptr_23
move $r0 $$retv               ; copy the return value
mcp  $r4 $r0 $r3              ; mcp dst src len
sw   $r1 $r4 i0               ; store word
sw   $r1 $r3 i1               ; store word
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for number_of_bytes_89
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i1               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_92
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i76                ; call ptr_87
move $r0 $$retv               ; copy the return value
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_93
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slice)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i16        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $$locbase         ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i88                ; call from_88
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i32        ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i59                ; call number_of_bytes_89
move $r0 $$retv               ; copy the return value
lw   $r4 $r3 i0               ; load word
lw   $r3 $r3 i1               ; load word
sw   $r1 $r4 i0               ; store word
sw   $r1 $r3 i1               ; store word
sw   $r1 $r0 i2               ; store word
move $$retv $r1               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for sha256_94
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
load $r3 data_11              ; get local constant
addi $r4 $$locbase i48        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i48        ; get offset to local
addi $r4 $$locbase i24        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i76                ; call ptr_92
move $r4 $$retv               ; copy the return value
movi $r5 i24                  ; get length for mcp
mcp  $$locbase $r0 $r5        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i200               ; call len_78
move $r0 $$retv               ; copy the return value
s256 $r3 $r4 $r0              ; s256 hash ptr bytes
movi $r0 i32                  ; get length for mcp
mcp  $r1 $r3 $r0              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for require_98
cfei i1064                    ; allocate 1064 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (condition)
move $r1 $$arg1               ; save arg 1 (value)
move $r2 $$reta               ; save reta
eq   $r0 $r0 $zero
jnzf $r0 $zero i2
move $$retv $zero             ; set return value
jmpf $zero i331
addi $r0 $$locbase i160       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i815               ; call new_39
move $r2 $$retv               ; copy the return value
lw   $r0 $r1 i0               ; load word
eq   $r1 $r0 $zero
jnzf $r1 $zero i285
eq   $r1 $r0 $one
jnzf $r1 $zero i265
movi $r1 i2                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i243
movi $r1 i3                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i221
movi $r1 i4                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i199
movi $r1 i5                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i177
movi $r1 i6                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i155
movi $r1 i7                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i133
movi $r1 i8                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i111
movi $r1 i9                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i89
movi $r1 i10                  ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i67
movi $r1 i11                  ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i45
movi $r1 i12                  ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i23
movi $r1 i13                  ; initialize constant into register
eq   $r0 $r0 $r1
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r0 $$locbase i512       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i136       ; get offset to local
movi $r2 i13                  ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i916               ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i752       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
jmpf $zero i17
addi $r0 $$locbase i488       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i112       ; get offset to local
movi $r2 i12                  ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i934               ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i752       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i776       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i464       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i88        ; get offset to local
movi $r2 i11                  ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i953               ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i776       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i800       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i728       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i368       ; get offset to local
movi $r2 i10                  ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i972               ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i800       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i872       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i704       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i344       ; get offset to local
movi $r2 i9                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i991               ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i872       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i896       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i680       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i320       ; get offset to local
movi $r2 i8                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1010              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i896       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i920       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i656       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i296       ; get offset to local
movi $r2 i7                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1029              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i920       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i944       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i632       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i272       ; get offset to local
movi $r2 i6                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1048              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i944       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i968       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i608       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i248       ; get offset to local
movi $r2 i5                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1067              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i968       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i992       ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i584       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i224       ; get offset to local
movi $r2 i4                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1086              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i992       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i1016      ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i560       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i200       ; get offset to local
movi $r2 i3                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1105              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1016      ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i1040      ; get offset to local
jmpf $zero i17
addi $r0 $$locbase i440       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i64        ; get offset to local
movi $r2 i2                   ; initialize constant into register
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1124              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1040      ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i824       ; get offset to local
jmpf $zero i16
addi $r0 $$locbase i416       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i40        ; get offset to local
move $$arg0 $one              ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1142              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i824       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i848       ; get offset to local
jmpf $zero i16
addi $r0 $$locbase i392       ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i16        ; get offset to local
move $$arg0 $zero             ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1160              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i848       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i536       ; get offset to local
sw   $$locbase $r1 i67        ; store word
sw   $$locbase $r2 i68        ; store word
sw   $$locbase $r3 i69        ; store word
addi $r1 $$locbase i184       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1106              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $$locbase $r0 $r1        ; copy memory with mem_copy
load $r0 data_24              ; literal instantiation
lw   $r1 $$locbase i0         ; load slice ptr
lw   $r2 $$locbase i1         ; load slice size
logd $zero $r0 $r1 $r2        ; log slice
load $r0 data_23              ; literal instantiation
rvrt $r0
cfsi i1064                    ; free 1064 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for is_some_102
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
move $r2 $one                 ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r2 $zero                ; parameter from branch to block argument
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_103
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i128                 ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i120                 ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for msg_sender_address_104
cfei i208                     ; allocate 208 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
addi $r2 $$locbase i80        ; get offset to local
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i52                ; call msg_sender_106
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i128       ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i40        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i19                ; call unwrap_105
move $r2 $$retv               ; copy the return value
movi $r3 i40                  ; get length for mcp
mcp  $$locbase $r2 $r3        ; copy memory with mem_copy
lw   $r2 $$locbase i0         ; load word
eq   $r2 $r2 $zero
jnzf $r2 $zero i1
rvrt $zero
addi $r2 $$locbase i8         ; get offset to element
addi $r3 $$locbase i176       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
move $$retv $r0               ; set return value
cfsi i208                     ; free 208 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_105
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i48                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i40                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for msg_sender_106
cfei i1448                    ; allocate 1448 bytes for locals and 0 slots for call arguments.
move $r6 $$arg0               ; save arg 0 (__ret_value)
move $r5 $$reta               ; save reta
gm   $r0 i1                   ; gm r1 i1
jnzf $r0 $zero i26
addi $r0 $$locbase i336       ; get offset to local
sw   $$locbase $zero i42      ; store word
addi $r1 $$locbase i384       ; get offset to local
sw   $$locbase $one i48       ; store word
gm   $r2 i2                   ; gm r1 i2
addi $r3 $$locbase i936       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i712       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i365               ; call from_118
move $r2 $$retv               ; copy the return value
addi $r3 $r1 i8               ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $r0 i8               ; get offset to element
movi $r3 i40                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i1256      ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r3 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i256
addi $r0 $$locbase i624       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i279               ; call tx_type_110
move $r0 $$retv               ; copy the return value
lw   $r0 $r0 i0               ; load word
eq   $r1 $r0 $zero
jnzf $r1 $zero i6
eq   $r0 $r0 $one
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
gtf  $r4 $zero i259           ; get transaction field
jmpf $zero i1
gtf  $r4 $zero i5             ; get transaction field
addi $r0 $$locbase i48        ; get offset to local
sw   $$locbase $zero i6       ; store word
addi $r1 $$locbase i1336      ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $r7 $zero                ; parameter from branch to block argument
lt   $r0 $r7 $r4
jnzf $r0 $zero i36
addi $r0 $$locbase i1336      ; get offset to local
addi $r1 $$locbase i584       ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i167       ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i12
lw   $r0 $$locbase i73        ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r0 $$locbase i464       ; get offset to local
sw   $$locbase $one i58       ; store word
sw   $$locbase $one i62       ; store word
addi $r2 $$locbase i1128      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i13
addi $r0 $$locbase i584       ; get offset to local
addi $r0 $r0 i8               ; get offset to element
addi $r1 $$locbase i1304      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i424       ; get offset to local
sw   $$locbase $zero i53      ; store word
addi $r2 $r1 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i1128      ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
addi $r1 $$locbase i1168      ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r1 $r2 $r0              ; copy memory with mem_copy
jmpf $zero i153
addi $r0 $$locbase i632       ; get offset to local
move $$arg0 $r7               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i239               ; call input_type_113
move $r0 $$retv               ; copy the return value
lw   $r0 $r0 i0               ; load word
eq   $r1 $r0 $zero
jnzf $r1 $zero i11
movi $r1 i2                   ; initialize constant into register
eq   $r1 $r0 $r1
jnzf $r1 $zero i8
move $$arg0 $r7               ; pass arg 0
move $$arg1 $one              ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i256               ; call add_115
move $r7 $$retv               ; copy the return value
jmpb $zero i58
eq   $r1 $r0 $zero
jnzf $r1 $zero i32
movi $r1 i2                   ; initialize constant into register
eq   $r0 $r0 $r1
jnzf $r0 $zero i8
move $$arg0 $r7               ; pass arg 0
move $$arg1 $one              ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i243               ; call add_115
move $r7 $$retv               ; copy the return value
jmpb $zero i71
addi $r0 $$locbase i176       ; get offset to local
sw   $$locbase $one i22       ; store word
gtf  $r1 $r7 i576             ; get transaction field
addi $r2 $$locbase i904       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i680       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i245               ; call from_118
move $r1 $$retv               ; copy the return value
addi $r2 $r0 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i1088      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r3 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i40
addi $r0 $$locbase i640       ; get offset to local
move $$arg0 $r7               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i183               ; call input_type_113
move $r0 $$retv               ; copy the return value
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i6
addi $r0 $$locbase i216       ; get offset to local
sw   $$locbase $zero i27      ; store word
addi $r2 $$locbase i1048      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i20
addi $r0 $$locbase i88        ; get offset to local
sw   $$locbase $one i11       ; store word
gtf  $r1 $r7 i515             ; get transaction field
addi $r2 $$locbase i872       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i648       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i207               ; call from_118
move $r1 $$retv               ; copy the return value
addi $r2 $r0 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i1048      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
addi $r3 $$locbase i1088      ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r3 $r2 $r0              ; copy memory with mem_copy
addi $r0 $$locbase i1408      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
addi $r0 $$locbase i1336      ; get offset to local
addi $r1 $$locbase i544       ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i167       ; load word
eq   $r0 $r0 $one
move $r1 $zero                ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r1 $one                 ; parameter from branch to block argument
jnzf $r1 $zero i98
addi $r0 $$locbase i1408      ; get offset to local
addi $r1 $$locbase i968       ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i744       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i190               ; call unwrap_122
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1336      ; get offset to local
addi $r2 $$locbase i1008      ; get offset to local
movi $r3 i40                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i776       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i178               ; call unwrap_122
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i808       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i840       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1411              ; call eq_50
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i52
addi $r0 $$locbase i296       ; get offset to local
sw   $$locbase $one i37       ; store word
sw   $$locbase $zero i41      ; store word
addi $r1 $$locbase i1168      ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i504       ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i146       ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i24
lw   $r0 $$locbase i63        ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r0 $$locbase i504       ; get offset to local
addi $r0 $r0 i8               ; get offset to element
addi $r1 $$locbase i1376      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i128       ; get offset to local
sw   $$locbase $zero i16      ; store word
addi $r2 $$locbase i256       ; get offset to local
sw   $$locbase $zero i32      ; store word
addi $r3 $r2 i8               ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $r1 i8               ; get offset to element
movi $r3 i40                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i1208      ; get offset to local
movi $r0 i48                  ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i9
addi $r0 $$locbase i504       ; get offset to local
addi $r0 $r0 i32              ; get offset to element
sw   $$locbase $one i0        ; store word
addi $r1 $$locbase i40        ; get offset to element
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i1208      ; get offset to local
movi $r0 i48                  ; get length for mcp
mcp  $r2 $$locbase $r0        ; copy memory with mem_copy
addi $r3 $$locbase i1256      ; get offset to local
movi $r0 i48                  ; get length for mcp
mcp  $r3 $r2 $r0              ; copy memory with mem_copy
movi $r0 i48                  ; get length for mcp
mcp  $r6 $r3 $r0              ; copy memory with mem_copy
move $$retv $r6               ; set return value
jmpf $zero i20
move $$arg0 $r7               ; pass arg 0
move $$arg1 $one              ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i71                ; call add_115
move $r7 $$retv               ; copy the return value
jmpb $zero i243
addi $r0 $$locbase i1408      ; get offset to local
addi $r1 $$locbase i1336      ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r7               ; pass arg 0
move $$arg1 $one              ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i59                ; call add_115
move $r7 $$retv               ; copy the return value
jmpb $zero i255
cfsi i1448                    ; free 1448 bytes for locals and 0 slots for extra call arguments.
move $$reta $r5               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for tx_type_110
cfei i8                       ; allocate 8 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
gtf  $r2 $zero i1             ; get transaction field
eq   $r3 $r2 $zero
jnzf $r3 $zero i5
eq   $r2 $r2 $one
jnzf $r2 $zero i1
rvrt $zero
move $r2 $one                 ; parameter from branch to block argument
jmpf $zero i1
move $r2 $zero                ; parameter from branch to block argument
sw   $r0 $r2 i0               ; store word
move $$retv $r0               ; set return value
cfsi i8                       ; free 8 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for input_type_113
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (index)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
gtf  $r0 $r0 i512             ; get transaction field
eq   $r3 $r0 $zero
jnzf $r3 $zero i11
eq   $r3 $r0 $one
jnzf $r3 $zero i6
movi $r3 i2                   ; initialize constant into register
eq   $r0 $r0 $r3
jnzf $r0 $zero i1
rvrt $zero
movi $r0 i2                   ; initialize constant into register
jmpf $zero i1
move $r0 $one                 ; parameter from branch to block argument
addi $r3 $$locbase i8         ; get offset to local
jmpf $zero i2
addi $r0 $$locbase i8         ; get offset to local
move $r0 $zero                ; parameter from branch to block argument
sw   $r1 $r0 i0               ; store word
move $$retv $r1               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for add_115
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
add  $r0 $r0 $r1
movi $r1 i65535               ; initialize constant into register
gt   $r1 $r0 $r1
jnzf $r1 $zero i2
move $$retv $r0               ; set return value
jmpf $zero i1
rvrt $zero
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_118
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (bits)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_122
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i40                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for cancel_order_internal_124
cfei i376                     ; allocate 376 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (order)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i12              ; load word
eq   $r3 $r3 $zero
eq   $r3 $r3 $zero
addi $r4 $$locbase i56        ; get offset to local
movi $r5 i10                  ; initialize constant into register
sw   $$locbase $r5 i7         ; store word
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i892               ; call require_98
addi $r3 $$locbase i64        ; get offset to local
movi $r4 i120                 ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $$locbase         ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i37                ; call order_return_asset_amount_125
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i336       ; get offset to local
movi $r5 i40                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $r0 i96              ; get offset to element
addi $r4 $$locbase i320       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i40        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2277              ; call flip_172
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i184       ; get offset to local
movi $r5 i120                 ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i304       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r0 $r3 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1048              ; call remove_update_order_internal_170
addi $r0 $$locbase i336       ; get offset to local
movi $r3 i40                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i376                     ; free 376 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for order_return_asset_amount_125
cfei i752                     ; allocate 752 bytes for locals and 0 slots for call arguments.
move $r6 $$arg0               ; save arg 0 (order)
move $r5 $$arg1               ; save arg 1 (__ret_value)
move $r4 $$reta               ; save reta
addi $r0 $r6 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
jnzf $r0 $zero i93
load $r0 data_7               ; get local constant
load $r1 data_7               ; get local constant
addi $r2 $$locbase i40        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i9       ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $r6 i64              ; get offset to element
addi $r1 $$locbase i568       ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i640       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i272       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2549              ; call get_198
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i496       ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i240       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2480              ; call slot_182
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i344       ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1519              ; call offset_67
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i464       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i192       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i75                ; call read_128
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i416       ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i152       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i42                ; call unwrap_126
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i712       ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $ssp i8              ; configurable QUOTE_TOKEN address
lw   $r1 $r6 i12              ; load word
lw   $r2 $$locbase i93        ; load word
lw   $r3 $r6 i14              ; load word
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i269               ; call base_size_to_quote_amount_139
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i112       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $r1 i18        ; store word
addi $r1 $$locbase i672       ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r1 $r2 $r0              ; copy memory with mem_copy
jmpf $zero i10
addi $r0 $r6 i64              ; get offset to element
addi $r1 $r6 i96              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
addi $r0 $$locbase i32        ; get offset to element
movi $r2 i8                   ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i672       ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
movi $r0 i40                  ; get length for mcp
mcp  $r5 $r1 $r0              ; copy memory with mem_copy
move $$retv $r5               ; set return value
cfsi i752                     ; free 752 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_126
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i48                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i40                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_128
cfei i304                     ; allocate 304 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i144       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i43                ; call slot_calculator_129
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i224       ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i224       ; get offset to local
addi $r1 $$locbase i272       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
lw   $r0 $$locbase i32        ; load word
lw   $r1 $$locbase i33        ; load word
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r0 $r4
movi $r5 i8                   ; initialize constant into register
mul  $r4 $r5 $r4
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
addi $r5 $$locbase i272       ; get offset to local
srwq $r4 $r0 $r5 $r0          ; access a sequence of storage slots
jnzf $r0 $zero i6
addi $r0 $$locbase i48        ; get offset to local
sw   $$locbase $zero i6       ; store word
addi $r4 $$locbase i176       ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r4 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i10
sw   $$locbase $one i0        ; store word
movi $r0 i8                   ; initialize constant into register
mul  $r0 $r0 $r1
add  $r0 $r4 $r0
addi $r1 $$locbase i8         ; get offset to element
movi $r4 i40                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i176       ; get offset to local
movi $r0 i48                  ; get length for mcp
mcp  $r4 $$locbase $r0        ; copy memory with mem_copy
movi $r0 i48                  ; get length for mcp
mcp  $r2 $r4 $r0              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i304                     ; free 304 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for slot_calculator_129
cfei i368                     ; allocate 368 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r8 $$arg2               ; save arg 2 (__ret_value)
move $r7 $$reta               ; save reta
movi $r2 i8                   ; initialize constant into register
mul  $r2 $r1 $r2
movi $r3 i40                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i31                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i4                   ; initialize constant into register
mod  $r1 $r1 $r3
movi $r3 i8                   ; initialize constant into register
mul  $r3 $r1 $r3
movi $r4 i40                  ; initialize constant into register
add  $r3 $r3 $r4
movi $r4 i31                  ; initialize constant into register
add  $r3 $r3 $r4
movi $r4 i5                   ; initialize constant into register
srl  $r3 $r3 $r4
addi $r4 $$locbase i48        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r4 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
addi $r4 $$locbase i112       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1728              ; call as_u256_62
move $r2 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1736              ; call as_u256_62
move $r4 $$retv               ; copy the return value
addi $r5 $$locbase i176       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r2 $r6              ; copy memory with mem_copy
addi $r2 $$locbase i304       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r2 $r4 $r6              ; copy memory with mem_copy
addi $r4 $$locbase i240       ; get offset to local
wqop $r4 $r5 $r2 i33
addi $r2 $$locbase i208       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i240       ; get offset to local
addi $r4 $$locbase i272       ; get offset to local
wqop $r4 $r2 $r0 i32
addi $r0 $$locbase i336       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i80        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
sw   $$locbase $r3 i4         ; store word
sw   $$locbase $r1 i5         ; store word
movi $r0 i48                  ; get length for mcp
mcp  $r8 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r8               ; set return value
cfsi i368                     ; free 368 bytes for locals and 0 slots for extra call arguments.
move $$reta $r7               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for sha256_134
cfei i168                     ; allocate 168 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (s)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1704              ; call new_70
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i144       ; get offset to local
addi $r4 $$locbase i80        ; get offset to local
movi $r5 i64                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i20                ; call hash_135
addi $r0 $$locbase i144       ; get offset to local
addi $r3 $$locbase i56        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1301              ; call sha256_94
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i168                     ; free 168 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for hash_135
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (state)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i32        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2192              ; call hash_190
addi $r0 $r0 i32              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1694              ; call hash_75
move $$retv $zero             ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for base_size_to_quote_amount_139
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (base_size)
move $r1 $$arg1               ; save arg 1 (base_decimals)
move $r2 $$arg2               ; save arg 2 (base_price)
move $r3 $$reta               ; save reta
lw   $r4 $ssp i0              ; load word
add  $r1 $r1 $r4
load $r4 data_3               ; literal instantiation
gt   $r4 $r1 $r4
jnzf $r4 $zero i14
lw   $r4 $ssp i5              ; load word
sub  $r1 $r1 $r4
movi $r4 i10                  ; initialize constant into register
exp  $r1 $r4 $r1              ; exp r3 r1 r2
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8                 ; call mul_div_140
move $r0 $$retv               ; copy the return value
move $$retv $r0               ; set return value
jmpf $zero i1
rvrt $zero
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for mul_div_140
cfei i240                     ; allocate 240 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (mul_to)
move $r2 $$arg2               ; save arg 2 (div_to)
move $r3 $$reta               ; save reta
sw   $$locbase $zero i0       ; store word
sw   $$locbase $r0 i1         ; store word
addi $r0 $$locbase i64        ; get offset to local
move $$arg0 $$locbase         ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i139               ; call from_148
move $r0 $$retv               ; copy the return value
sw   $$locbase $zero i2       ; store word
sw   $$locbase $r1 i3         ; store word
addi $r1 $$locbase i16        ; get offset to local
addi $r4 $$locbase i80        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i128               ; call from_148
move $r1 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i160       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r0 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i48        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i55                ; call multiply_141
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i224       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
sw   $$locbase $r2 i5         ; store word
addi $r0 $$locbase i32        ; get offset to local
addi $r1 $$locbase i96        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i99                ; call from_148
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i224       ; get offset to local
addi $r2 $$locbase i176       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i112       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i101               ; call divide_149
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i208       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i208       ; get offset to local
addi $r1 $$locbase i128       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i529               ; call as_u64_166
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i192       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i501               ; call unwrap_165
move $r0 $$retv               ; copy the return value
move $$retv $r0               ; set return value
cfsi i240                     ; free 240 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for multiply_141
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
lw   $r4 $r0 i0               ; load word
eq   $r4 $r4 $zero
jnzf $r4 $zero i2
lw   $r4 $r1 i0               ; load word
eq   $r4 $r4 $zero
eq   $r4 $r4 $zero
jnzf $r4 $zero i36
lw   $r4 $r0 i1               ; load word
lw   $r5 $r1 i1               ; load word
move $r6 $flag                ; return value from inline asm (flag)
movi $r7 i2                   ; initialize constant into register
or   $r7 $r6 $r7
flag $r7                      ; flag flag_val
sw   $$locbase $zero i0       ; store word
sw   $$locbase $zero i1       ; store word
move $r7 $$locbase            ; copy const asm init to GP reg
mul  $r4 $r4 $r5              ; mul product left right
move $r5 $of                  ; move overflow of
sw   $r7 $r5 i0               ; sw result_ptr overflow i0
sw   $r7 $r4 i1               ; sw result_ptr product i1
flag $r6                      ; flag new_flags
lw   $r6 $$locbase i0         ; load word
lw   $r4 $$locbase i1         ; load word
lw   $r5 $r0 i0               ; load word
eq   $r5 $r5 $zero
jnzf $r5 $zero i9
lw   $r5 $r1 i0               ; load word
eq   $r5 $r5 $zero
jnzf $r5 $zero i1
jmpf $zero i4
lw   $r0 $r0 i0               ; load word
lw   $r1 $r1 i1               ; load word
mul  $r0 $r0 $r1
add  $r6 $r6 $r0
jmpf $zero i4
lw   $r0 $r0 i1               ; load word
lw   $r1 $r1 i0               ; load word
mul  $r0 $r0 $r1
add  $r6 $r6 $r0
sw   $r2 $r6 i0               ; store word
sw   $r2 $r4 i1               ; store word
move $$retv $r2               ; set return value
jmpf $zero i2
load $r0 data_25              ; literal instantiation
rvrt $r0
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_148
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (components)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
lw   $r0 $r0 i1               ; load word
sw   $r1 $r3 i0               ; store word
sw   $r1 $r0 i1               ; store word
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i2047                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for divide_149
cfei i368                     ; allocate 368 bytes for locals and 0 slots for call arguments.
move $r7 $$arg0               ; save arg 0 (self)
move $r6 $$arg1               ; save arg 1 (divisor)
move $r5 $$arg2               ; save arg 2 (__ret_value)
move $r4 $$reta               ; save reta
addi $r0 $$locbase i144       ; get offset to local
sw   $$locbase $zero i18      ; store word
sw   $$locbase $zero i19      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $$locbase         ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i30                ; call from_148
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r0 $r0 i1               ; load word
addi $r2 $$locbase i224       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r6 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i240       ; get offset to local
sw   $$locbase $r1 i30        ; store word
sw   $$locbase $r0 i31        ; store word
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i238               ; call eq_151
move $r0 $$retv               ; copy the return value
eq   $r0 $r0 $zero
eq   $r0 $r0 $zero
jnzf $r0 $zero i227
lw   $r0 $r7 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i1
jmpf $zero i2
lw   $r0 $r6 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i202
addi $r0 $$locbase i64        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i240               ; call new_153
move $r0 $$retv               ; copy the return value
lw   $r3 $r0 i0               ; load word
lw   $r8 $r0 i1               ; load word
addi $r0 $$locbase i80        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i231               ; call new_153
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i352       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r9 i127                 ; initialize constant into register
addi $r0 $$locbase i288       ; get offset to local
sw   $$locbase $r3 i36        ; store word
sw   $$locbase $r8 i37        ; store word
addi $r1 $$locbase i112       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $one              ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i227               ; call lsh_155
move $r0 $$retv               ; copy the return value
lw   $r3 $r0 i0               ; load word
lw   $r8 $r0 i1               ; load word
addi $r0 $$locbase i352       ; get offset to local
addi $r1 $$locbase i304       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i128       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $one              ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i212               ; call lsh_155
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i352       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r10 $$locbase i45       ; load word
move $$arg0 $r9               ; pass arg 0
movi $r0 i128                 ; initialize constant into register
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i283               ; call ge_156
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i52
move $$arg0 $r9               ; pass arg 0
movi $r0 i64                  ; initialize constant into register
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i274               ; call ge_156
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i24
lw   $r0 $r7 i0               ; load word
movi $r1 i64                  ; initialize constant into register
sub  $r1 $r1 $r9
sll  $r0 $r0 $r1
lw   $r1 $r7 i0               ; load word
srl  $r1 $r1 $r9
lw   $r2 $r7 i1               ; load word
srl  $r2 $r2 $r9
add  $r0 $r2 $r0
addi $r2 $$locbase i208       ; get offset to local
sw   $$locbase $r1 i26        ; store word
sw   $$locbase $r0 i27        ; store word
addi $r0 $$locbase i48        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i144               ; call from_148
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i336       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r0 $r0 i1               ; load word
jmpf $zero i29
lw   $r0 $r7 i0               ; load word
movi $r1 i64                  ; initialize constant into register
sub  $r1 $r9 $r1
srl  $r0 $r0 $r1
addi $r1 $$locbase i176       ; get offset to local
sw   $$locbase $zero i22      ; store word
sw   $$locbase $r0 i23        ; store word
addi $r0 $$locbase i32        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i163               ; call from_148
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i336       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r0 $r0 i1               ; load word
jmpf $zero i10
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i128               ; call new_153
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i336       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r0 $r0 i1               ; load word
and  $r0 $r0 $one
or   $r0 $r10 $r0
sw   $$locbase $r0 i45        ; store word
addi $r0 $$locbase i352       ; get offset to local
lw   $r1 $$locbase i44        ; load word
lw   $r2 $r6 i0               ; load word
gt   $r1 $r1 $r2
jnzf $r1 $zero i8
lw   $r1 $r0 i0               ; load word
lw   $r2 $r6 i0               ; load word
eq   $r1 $r1 $r2
jnzf $r1 $zero i1
jmpf $zero i3
lw   $r1 $r0 i1               ; load word
lw   $r2 $r6 i1               ; load word
gt   $r1 $r1 $r2
jnzf $r1 $zero i13
addi $r1 $$locbase i256       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i272       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r0 $r6 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i76                ; call eq_151
move $r1 $$retv               ; copy the return value
jnzf $r1 $zero i1
jmpf $zero i38
addi $r0 $$locbase i352       ; get offset to local
addi $r1 $$locbase i320       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i192       ; get offset to local
movi $r10 i16                 ; get length for mcp
mcp  $r2 $r6 $r10             ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i188               ; call lt_163
move $r1 $$retv               ; copy the return value
eq   $r1 $r1 $zero
eq   $r1 $r1 $zero
jnzf $r1 $zero i29
lw   $r1 $r0 i0               ; load word
lw   $r2 $r6 i0               ; load word
sub  $r10 $r1 $r2
lw   $r1 $r0 i1               ; load word
lw   $r2 $r6 i1               ; load word
lt   $r1 $r1 $r2
jnzf $r1 $zero i4
lw   $r0 $r0 i1               ; load word
lw   $r1 $r6 i1               ; load word
sub  $r0 $r0 $r1
jmpf $zero i7
lw   $r1 $r6 i1               ; load word
lw   $r0 $r0 i1               ; load word
sub  $r0 $r1 $r0
sub  $r0 $r0 $one
load $r1 data_26              ; literal instantiation
sub  $r0 $r1 $r0
sub  $r10 $r10 $one
sw   $$locbase $r10 i44       ; store word
sw   $$locbase $r0 i45        ; store word
or   $r8 $r8 $one
eq   $r0 $r9 $zero
jnzf $r0 $zero i2
sub  $r9 $r9 $one
jmpb $zero i174
sw   $r5 $r3 i0               ; store word
sw   $r5 $r8 i1               ; store word
move $$retv $r5               ; set return value
jmpf $zero i22
load $r0 data_25              ; literal instantiation
rvrt $r0
lw   $r0 $r7 i1               ; load word
lw   $r1 $r6 i1               ; load word
div  $r0 $r0 $r1
addi $r1 $$locbase i160       ; get offset to local
sw   $$locbase $zero i20      ; store word
sw   $$locbase $r0 i21        ; store word
addi $r0 $$locbase i16        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i271               ; call from_148
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r5 $r0 $r1              ; copy memory with mem_copy
move $$retv $r5               ; set return value
jmpf $zero i2
load $r0 data_25              ; literal instantiation
rvrt $r0
cfsi i368                     ; free 368 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i2047                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for eq_151
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i1               ; load word
lw   $r4 $r1 i1               ; load word
eq   $r3 $r3 $r4
jnzf $r3 $zero i1
jmpf $zero i3
lw   $r0 $r0 i0               ; load word
lw   $r1 $r1 i0               ; load word
eq   $r3 $r0 $r1
move $$retv $r3               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_153
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
sw   $r0 $zero i0             ; store word
sw   $r0 $zero i1             ; store word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for lsh_155
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (rhs)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
move $$arg0 $r1               ; pass arg 0
movi $r4 i128                 ; initialize constant into register
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i68                ; call ge_156
move $r4 $$retv               ; copy the return value
jnzf $r4 $zero i51
move $$arg0 $r1               ; pass arg 0
movi $r4 i64                  ; initialize constant into register
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i59                ; call ge_156
move $r4 $$retv               ; copy the return value
jnzf $r4 $zero i24
lw   $r4 $r0 i1               ; load word
movi $r5 i64                  ; initialize constant into register
sub  $r5 $r5 $r1
srl  $r4 $r4 $r5
lw   $r5 $r0 i0               ; load word
sll  $r5 $r5 $r1
add  $r4 $r5 $r4
lw   $r0 $r0 i1               ; load word
sll  $r0 $r0 $r1
addi $r1 $$locbase i64        ; get offset to local
sw   $$locbase $r4 i8         ; store word
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i16        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i359               ; call from_148
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
jmpf $zero i28
lw   $r0 $r0 i1               ; load word
movi $r4 i64                  ; initialize constant into register
sub  $r1 $r1 $r4
sll  $r0 $r0 $r1
addi $r1 $$locbase i48        ; get offset to local
sw   $$locbase $r0 i6         ; store word
sw   $$locbase $zero i7       ; store word
move $$arg0 $r1               ; pass arg 0
move $$arg1 $$locbase         ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i377               ; call from_148
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
jmpf $zero i10
addi $r0 $$locbase i32        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i84                ; call new_153
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ge_156
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
gt   $r3 $r0 $r1
jnzf $r3 $zero i1
eq   $r3 $r0 $r1
move $$retv $r3               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for lt_163
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
lw   $r4 $r1 i0               ; load word
lt   $r3 $r3 $r4
jnzf $r3 $zero i8
lw   $r3 $r0 i0               ; load word
lw   $r4 $r1 i0               ; load word
eq   $r3 $r3 $r4
jnzf $r3 $zero i1
jmpf $zero i3
lw   $r0 $r0 i1               ; load word
lw   $r1 $r1 i1               ; load word
lt   $r3 $r0 $r1
move $$retv $r3               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_165
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i1
rvrt $zero
lw   $r0 $$locbase i1         ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for as_u64_166
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
eq   $r3 $r3 $zero
jnzf $r3 $zero i7
addi $r0 $$locbase i16        ; get offset to local
sw   $$locbase $one i2        ; store word
sw   $$locbase $zero i3       ; store word
addi $r4 $$locbase i32        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r4 $r0 $r3              ; copy memory with mem_copy
jmpf $zero i8
sw   $$locbase $zero i0       ; store word
addi $r0 $r0 i8               ; get offset to element
addi $r3 $$locbase i8         ; get offset to element
movi $r4 i8                   ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i32        ; get offset to local
movi $r0 i16                  ; get length for mcp
mcp  $r4 $$locbase $r0        ; copy memory with mem_copy
movi $r0 i16                  ; get length for mcp
mcp  $r1 $r4 $r0              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i4095                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for remove_update_order_internal_170
cfei i7136                    ; allocate 7136 bytes for locals and 0 slots for call arguments.
move $r6 $$arg0               ; save arg 0 (order)
move $r5 $$arg1               ; save arg 1 (base_size)
move $r4 $$reta               ; save reta
addi $r0 $r6 i96              ; get offset to element
addi $r1 $$locbase i3072      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r5 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i1784      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1198              ; call flip_172
move $r1 $$retv               ; copy the return value
movi $r2 i6216                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i6232                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1162              ; call eq_171
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i145
movi $r0 i7016                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i120                 ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
movi $r0 i7016                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r1 $r0 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
eq   $r1 $r1 $zero
jnzf $r1 $zero i1
jmpf $zero i3
addi $r1 $r5 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
eq   $r1 $r1 $zero
jnzf $r1 $zero i72
addi $r1 $r0 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
jnzf $r1 $zero i1
jmpf $zero i2
addi $r1 $r5 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
jnzf $r1 $zero i46
lw   $r1 $r0 i0               ; load word
lw   $r2 $r5 i0               ; load word
gt   $r1 $r1 $r2
jnzf $r1 $zero i32
lw   $r1 $r0 i0               ; load word
lw   $r2 $r5 i0               ; load word
lt   $r1 $r1 $r2
jnzf $r1 $zero i18
lw   $r0 $r0 i0               ; load word
lw   $r1 $r5 i0               ; load word
eq   $r0 $r0 $r1
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i2192      ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1228              ; call new_174
move $r0 $$retv               ; copy the return value
movi $r1 i6368                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
lw   $r1 $r0 i0               ; load word
addi $r0 $r0 i8               ; get offset to element
lb   $r2 $r0 i0               ; load byte
jmpf $zero i7
lw   $r1 $r5 i0               ; load word
lw   $r0 $r0 i0               ; load word
sub  $r1 $r1 $r0
addi $r0 $r5 i8               ; get offset to element
lb   $r2 $r0 i0               ; load byte
movi $r0 i6368                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r0 i6384                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
jmpf $zero i7
lw   $r1 $r0 i0               ; load word
lw   $r2 $r5 i0               ; load word
sub  $r1 $r1 $r2
addi $r0 $r0 i8               ; get offset to element
lb   $r2 $r0 i0               ; load byte
movi $r0 i6384                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r0 i6400                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
jmpf $zero i16
lw   $r0 $r0 i0               ; load word
lw   $r1 $r5 i0               ; load word
add  $r0 $r0 $r1
addi $r1 $$locbase i2816      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1218              ; call neg_from_177
move $r0 $$retv               ; copy the return value
movi $r1 i6400                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
lw   $r1 $r0 i0               ; load word
addi $r0 $r0 i8               ; get offset to element
lb   $r2 $r0 i0               ; load byte
movi $r0 i6416                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
jmpf $zero i16
lw   $r0 $r0 i0               ; load word
lw   $r1 $r5 i0               ; load word
add  $r0 $r0 $r1
addi $r1 $$locbase i2568      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1185              ; call from_175
move $r0 $$retv               ; copy the return value
movi $r1 i6416                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
lw   $r1 $r0 i0               ; load word
addi $r0 $r0 i8               ; get offset to element
lb   $r2 $r0 i0               ; load byte
load $r0 data_5               ; get local constant
load $r3 data_5               ; get local constant
movi $r5 i7016                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
addi $r5 $r5 i96              ; get offset to element
sw   $$locbase $r1 i889       ; store word
addi $r1 $r5 i8               ; get offset to element
sb   $r1 $r2 i0               ; store byte
addi $r1 $$locbase i464       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
sw   $$locbase $zero i62      ; store word
addi $r0 $r1 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r3 $r2              ; copy memory with mem_copy
movi $r0 i7016                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i7016                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i5016                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r3 $r1 $r5              ; copy memory with mem_copy
movi $r1 i5088                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r1 $r0 $r5              ; copy memory with mem_copy
movi $r0 i5120                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r5 i120                 ; get length for mcp
mcp  $r0 $r2 $r5              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1990              ; call insert_227
jmpf $zero i1006
load $r0 data_13              ; get local constant
load $r1 data_13              ; get local constant
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
addi $r0 $$locbase i40        ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r0 $r6 i32              ; get offset to element
addi $r1 $$locbase i3552      ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $$locbase $r2        ; copy memory with mem_copy
addi $r2 $$locbase i3624      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1352      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1342              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i5240                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i5312                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r6 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i2304      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2433              ; call get_250
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3280      ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i1288      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1256              ; call slot_182
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i2928      ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2743              ; call offset_67
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i3088      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i2832      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1096              ; call read_180
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1016      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i127       ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
load $r0 data_13              ; get local constant
load $r1 data_13              ; get local constant
load $r7 data_12              ; get local constant
load $r5 data_12              ; get local constant
lw   $r2 $$locbase i128       ; load word
sub  $r8 $r2 $one
addi $r2 $$locbase i320       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i44      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $r6 i32              ; get offset to element
addi $r1 $$locbase i3656      ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i3728      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1424      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1253              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i5352                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2376      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2413              ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i72        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r6 $r2              ; copy memory with mem_copy
addi $r2 $r1 i32              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i3440      ; get offset to local
movi $r2 i64                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i1160      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2813              ; call sha256_69
move $r0 $$retv               ; copy the return value
movi $r1 i6824                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6824                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3248      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1240      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1075              ; call slot_calculator_181
move $r0 $$retv               ; copy the return value
movi $r1 i6432                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i6952                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i808       ; load word
movi $r1 i6952                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
scwq $r1 $r0 $r0              ; clear a sequence of storage slots
movi $r1 i4464                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i11                  ; initialize constant into register
sw   $$locbase $r2 i558       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2343              ; call require_98
addi $r0 $$locbase i656       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r7 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i86      ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r5 $r2              ; copy memory with mem_copy
addi $r1 $r6 i32              ; get offset to element
addi $r2 $$locbase i3760      ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i3832      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1496      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1159              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i5424                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2408      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2319              ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3120      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2848      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i938               ; call read_180
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3424      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1101              ; call unwrap_or_196
move $r0 $$retv               ; copy the return value
sub  $r5 $r0 $one
eq   $r0 $r5 $r8
eq   $r0 $r0 $zero
jnzf $r0 $zero i182
load $r0 data_12              ; get local constant
load $r1 data_12              ; get local constant
addi $r2 $$locbase i944       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i122     ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $r6 i32              ; get offset to element
movi $r1 i4240                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
movi $r2 i4312                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1800      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1092              ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i5856                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i2616      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2252              ; call field_id_251
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i3216      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1224      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i871               ; call read_180
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i3536      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1034              ; call unwrap_or_196
move $r1 $$retv               ; copy the return value
eq   $r2 $r1 $zero
jnzf $r2 $zero i79
movi $r2 i5928                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i2648      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2216              ; call field_id_251
move $r2 $$retv               ; copy the return value
sub  $r3 $r1 $one
movi $r5 i4880                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r5 $r2 $r7              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1550              ; call write_220
movi $r2 i6000                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i2680      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2192              ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r2 i4704                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i2240      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1272              ; call sha256_211
move $r0 $$retv               ; copy the return value
movi $r2 i6792                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sub  $r0 $r1 $one
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1307              ; call offset_calculator_212
move $r0 $$retv               ; copy the return value
movi $r1 i6792                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4608                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i2120      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1068              ; call read_203
move $r0 $$retv               ; copy the return value
movi $r2 i6328                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i6
addi $r0 $$locbase i216       ; get offset to local
sw   $$locbase $zero i27      ; store word
movi $r2 i6328                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
movi $r0 i4472                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i1968      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1023              ; call unwrap_202
move $r0 $$retv               ; copy the return value
movi $r1 i6528                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6592                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r6 $r2              ; copy memory with mem_copy
wqcm $r0 $r1 $r0 i32
movi $r1 i5344                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12                  ; initialize constant into register
sw   $$locbase $r2 i668       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2585              ; call require_98
jmpf $zero i495
load $r0 data_12              ; get local constant
load $r1 data_12              ; get local constant
addi $r2 $$locbase i728       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i95      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $r6 i32              ; get offset to element
addi $r1 $$locbase i3864      ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i4000      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1568      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i912               ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i5496                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i2440      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2072              ; call field_id_251
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i3152      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i2864      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i691               ; call read_180
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i3504      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i854               ; call unwrap_or_196
move $r1 $$retv               ; copy the return value
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1121              ; call le_210
move $r1 $$retv               ; copy the return value
jnzf $r1 $zero i83
movi $r1 i5568                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2472      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i2030              ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r1 i4640                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2160      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1110              ; call sha256_211
move $r0 $$retv               ; copy the return value
movi $r1 i6728                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1146              ; call offset_calculator_212
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i536       ; get offset to local
sw   $$locbase $one i67       ; store word
movi $r2 i6728                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i6728                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
addi $r7 $$locbase i616       ; get offset to local
sw   $$locbase $r5 i77        ; store word
addi $r5 $r7 i8               ; get offset to element
movi $r9 i32                  ; get length for mcp
mcp  $r5 $r3 $r9              ; copy memory with mem_copy
movi $r3 i4736                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i40                  ; get length for mcp
mcp  $r3 $r7 $r5              ; copy memory with mem_copy
addi $r5 $$locbase i2272      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1137              ; call sha256_214
move $r3 $$retv               ; copy the return value
movi $r5 i6152                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r5 $r2 $r7              ; copy memory with mem_copy
movi $r2 i6184                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r2 $r3 $r7              ; copy memory with mem_copy
addi $r3 $$locbase i2744      ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
move $$arg3 $r3               ; pass arg 3
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1981              ; call new_252
move $r0 $$retv               ; copy the return value
addi $r2 $r1 i8               ; get offset to element
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r2 i6248                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r0 i80                  ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i6
addi $r0 $$locbase i136       ; get offset to local
sw   $$locbase $zero i17      ; store word
movi $r2 i6248                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r1 i80                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
addi $r0 $$locbase i1032      ; get offset to local
movi $r1 i80                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
lw   $r0 $$locbase i781       ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
load $r0 data_12              ; get local constant
load $r1 data_12              ; get local constant
addi $r2 $$locbase i1032      ; get offset to local
addi $r2 $r2 i8               ; get offset to element
movi $r3 i6656                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r3 $r2 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i3352      ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r3 $r2 $r5              ; copy memory with mem_copy
addi $r5 $$locbase i1320      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i695               ; call slot_182
move $r3 $$retv               ; copy the return value
addi $r5 $$locbase i3000      ; get offset to local
movi $r7 i72                  ; get length for mcp
mcp  $r5 $r2 $r7              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3304              ; call offset_67
move $r2 $$retv               ; copy the return value
movi $r5 i4512                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r5 $r3 $r7              ; copy memory with mem_copy
addi $r3 $$locbase i2000      ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i817               ; call read_203
move $r2 $$retv               ; copy the return value
movi $r3 i4344                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i40                  ; get length for mcp
mcp  $r3 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i1872      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i783               ; call unwrap_202
move $r2 $$retv               ; copy the return value
movi $r3 i6920                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r3 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i800       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i104     ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $r6 i32              ; get offset to element
addi $r1 $$locbase i4032      ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
movi $r2 i4104                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1640      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i691               ; call get_198
move $r3 $$retv               ; copy the return value
movi $r0 i5640                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i2504      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1851              ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3184      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2880      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i470               ; call read_180
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3520      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i633               ; call unwrap_or_196
move $r7 $$retv               ; copy the return value
lt   $r0 $r8 $r7
eq   $r0 $r0 $zero
jnzf $r0 $zero i294
load $r10 data_13             ; get local constant
load $r9 data_13              ; get local constant
movi $r0 i5712                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i2536      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1810              ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r1 i4672                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2208      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i890               ; call sha256_211
move $r0 $$retv               ; copy the return value
movi $r1 i6760                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r8               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i926               ; call offset_calculator_212
move $r11 $$retv              ; copy the return value
movi $r0 i6760                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i4544                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2040      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r11              ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i687               ; call read_203
move $r0 $$retv               ; copy the return value
movi $r1 i4384                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1904      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i653               ; call unwrap_202
move $r0 $$retv               ; copy the return value
movi $r1 i6624                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
sub  $r0 $r7 $one
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i888               ; call offset_calculator_212
move $r0 $$retv               ; copy the return value
movi $r1 i6760                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4576                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r2 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i2080      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i649               ; call read_203
move $r0 $$retv               ; copy the return value
movi $r1 i4424                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1936      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i615               ; call unwrap_202
move $r0 $$retv               ; copy the return value
movi $r1 i6888                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6760                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i6888                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4776                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r2 $r0 $r5              ; copy memory with mem_copy
movi $r0 i4816                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r11              ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i972               ; call write_218
movi $r0 i5784                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i2584      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1688              ; call field_id_251
move $r0 $$retv               ; copy the return value
sub  $r1 $r7 $one
movi $r2 i4848                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1022              ; call write_220
movi $r0 i6624                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i6560                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r6 $r2              ; copy memory with mem_copy
wqcm $r0 $r0 $r1 i32
movi $r1 i4808                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i12                  ; initialize constant into register
sw   $$locbase $r2 i601       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3038              ; call require_98
addi $r0 $$locbase i872       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r10 $r1             ; copy memory with mem_copy
sw   $$locbase $zero i113     ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r9 $r2              ; copy memory with mem_copy
addi $r1 $r6 i32              ; get offset to element
movi $r2 i4136                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4208                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1712      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i462               ; call get_198
move $r0 $$retv               ; copy the return value
movi $r1 i6920                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
add  $r2 $r8 $one
movi $r3 i4912                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r3 $r0 $r5              ; copy memory with mem_copy
movi $r0 i4984                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1010              ; call insert_222
load $r0 data_5               ; get local constant
load $r1 data_5               ; get local constant
addi $r2 $$locbase i392       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i53      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
movi $r0 i6080                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i2712      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1593              ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i256       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r6 $r2              ; copy memory with mem_copy
addi $r2 $r1 i32              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i3936      ; get offset to local
movi $r2 i64                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i1192      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3633              ; call sha256_69
move $r0 $$retv               ; copy the return value
movi $r1 i6856                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6856                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i2896      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1112      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3763              ; call slot_calculator_54
move $r0 $$retv               ; copy the return value
movi $r1 i6480                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i6480                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i6984                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i814       ; load word
movi $r1 i6984                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
scwq $r1 $r0 $r0              ; clear a sequence of storage slots
movi $r1 i6072                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i13                  ; initialize constant into register
sw   $$locbase $r2 i759       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3163              ; call require_98
move $$retv $zero             ; set return value
jmpf $zero i2
load $r0 data_25              ; literal instantiation
rvrt $r0
cfsi i7136                    ; free 7136 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i4095                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for eq_171
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
lw   $r4 $r1 i0               ; load word
eq   $r3 $r3 $r4
jnzf $r3 $zero i1
jmpf $zero i5
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
addi $r1 $r1 i8               ; get offset to element
lb   $r1 $r1 i0               ; load byte
eq   $r3 $r0 $r1
move $$retv $r3               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for flip_172
cfei i96                      ; allocate 96 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r5 $$arg1               ; save arg 1 (__ret_value)
move $r4 $$reta               ; save reta
addi $r1 $$locbase i32        ; get offset to local
move $$arg0 $one              ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i102               ; call neg_from_177
move $r1 $$retv               ; copy the return value
lw   $r2 $r0 i0               ; load word
eq   $r2 $r2 $zero
jnzf $r2 $zero i2
lw   $r2 $r1 i0               ; load word
eq   $r2 $r2 $zero
jnzf $r2 $zero i51
addi $r2 $r0 i8               ; get offset to element
lb   $r2 $r2 i0               ; load byte
eq   $r2 $r2 $zero
addi $r3 $r1 i8               ; get offset to element
lb   $r3 $r3 i0               ; load byte
eq   $r3 $r3 $zero
eq   $r2 $r2 $r3
jnzf $r2 $zero i25
addi $r2 $r0 i8               ; get offset to element
lb   $r2 $r2 i0               ; load byte
eq   $r2 $r2 $zero
addi $r3 $r1 i8               ; get offset to element
lb   $r3 $r3 i0               ; load byte
eq   $r3 $r3 $zero
eq   $r2 $r2 $r3
eq   $r2 $r2 $zero
jnzf $r2 $zero i1
rvrt $zero
lw   $r0 $r0 i0               ; load word
lw   $r1 $r1 i0               ; load word
mul  $r0 $r0 $r1
addi $r1 $$locbase i48        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i67                ; call neg_from_177
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i64        ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i14
lw   $r0 $r0 i0               ; load word
lw   $r1 $r1 i0               ; load word
mul  $r0 $r0 $r1
addi $r1 $$locbase i16        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i38                ; call from_175
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i64        ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i80        ; get offset to local
movi $r0 i16                  ; get length for mcp
mcp  $r1 $r2 $r0              ; copy memory with mem_copy
jmpf $zero i9
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i12                ; call new_174
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i80        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i16                  ; get length for mcp
mcp  $r5 $r1 $r0              ; copy memory with mem_copy
move $$retv $r5               ; set return value
cfsi i96                      ; free 96 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_174
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
sw   $r0 $zero i0             ; store word
addi $r2 $r0 i8               ; get offset to element
sb   $r2 $zero i0             ; store byte
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_175
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (b)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
sw   $r1 $r0 i0               ; store word
addi $r0 $r1 i8               ; get offset to element
sb   $r0 $zero i0             ; store byte
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for neg_from_177
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (value)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
eq   $r3 $r0 $zero
move $r4 $zero                ; parameter from branch to block argument
jnzf $r3 $zero i1
move $r4 $one                 ; parameter from branch to block argument
sw   $r1 $r0 i0               ; store word
addi $r0 $r1 i8               ; get offset to element
sb   $r0 $r4 i0               ; store byte
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_180
cfei i208                     ; allocate 208 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i80        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i32        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i47                ; call slot_calculator_181
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i128       ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i128       ; get offset to local
addi $r1 $$locbase i176       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
lw   $r0 $$locbase i20        ; load word
lw   $r1 $$locbase i21        ; load word
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r0 $r4
movi $r5 i8                   ; initialize constant into register
mul  $r4 $r5 $r4
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
addi $r5 $$locbase i176       ; get offset to local
srwq $r4 $r0 $r5 $r0          ; access a sequence of storage slots
jnzf $r0 $zero i6
addi $r0 $$locbase i16        ; get offset to local
sw   $$locbase $zero i2       ; store word
addi $r4 $$locbase i112       ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r4 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i14
sw   $$locbase $one i0        ; store word
movi $r0 i8                   ; initialize constant into register
mul  $r0 $r0 $r1
add  $r0 $r4 $r0
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4527              ; call read_17
move $r0 $$retv               ; copy the return value
sw   $$locbase $r0 i1         ; store word
addi $r4 $$locbase i112       ; get offset to local
movi $r0 i16                  ; get length for mcp
mcp  $r4 $$locbase $r0        ; copy memory with mem_copy
movi $r0 i16                  ; get length for mcp
mcp  $r2 $r4 $r0              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i208                     ; free 208 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for slot_calculator_181
cfei i368                     ; allocate 368 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r7 $$arg2               ; save arg 2 (__ret_value)
move $r6 $$reta               ; save reta
movi $r2 i8                   ; initialize constant into register
mul  $r2 $r1 $r2
movi $r3 i8                   ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i31                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i4                   ; initialize constant into register
mod  $r1 $r1 $r3
addi $r3 $$locbase i48        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
addi $r3 $$locbase i112       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3969              ; call as_u256_62
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i144       ; get offset to local
move $$arg0 $one              ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3977              ; call as_u256_62
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i176       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i304       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r2 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i240       ; get offset to local
wqop $r3 $r4 $r2 i33
addi $r2 $$locbase i208       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i240       ; get offset to local
addi $r3 $$locbase i272       ; get offset to local
wqop $r3 $r2 $r0 i32
addi $r0 $$locbase i336       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r3 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i80        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r3 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
sw   $$locbase $one i4        ; store word
sw   $$locbase $r1 i5         ; store word
movi $r0 i48                  ; get length for mcp
mcp  $r7 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r7               ; set return value
cfsi i368                     ; free 368 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for slot_182
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for hash_190
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (state)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3892              ; call hash_75
move $$retv $zero             ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_or_196
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r3 $$arg1               ; save arg 1 (default)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i5
lw   $r0 $$locbase i0         ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i3
load $r0 data_21              ; literal instantiation
rvrt $r0
lw   $r3 $$locbase i1         ; load word
move $$retv $r3               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for get_198
cfei i432                     ; allocate 432 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (key)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i264       ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1154              ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r1 $r4        ; copy memory with mem_copy
addi $r1 $$locbase i32        ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i200       ; get offset to local
movi $r1 i64                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i64        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2331              ; call sha256_134
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i400       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i400       ; get offset to local
addi $r1 $$locbase i400       ; get offset to local
addi $r4 $$locbase i336       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i368       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i128       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $r1               ; pass arg 3
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1131              ; call new_252
move $r0 $$retv               ; copy the return value
movi $r1 i72                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i432                     ; free 432 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_202
cfei i40                      ; allocate 40 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i40                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i40                      ; free 40 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_203
cfei i312                     ; allocate 312 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i160       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i80        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i51                ; call slot_calculator_204
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i232       ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i232       ; get offset to local
addi $r1 $$locbase i280       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
lw   $r0 $$locbase i33        ; load word
lw   $r1 $$locbase i34        ; load word
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r0 $r4
movi $r5 i8                   ; initialize constant into register
mul  $r4 $r5 $r4
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
addi $r5 $$locbase i280       ; get offset to local
srwq $r4 $r0 $r5 $r0          ; access a sequence of storage slots
jnzf $r0 $zero i6
addi $r0 $$locbase i40        ; get offset to local
sw   $$locbase $zero i5       ; store word
addi $r4 $$locbase i192       ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r4 $r0 $r1              ; copy memory with mem_copy
jmpf $zero i18
sw   $$locbase $one i0        ; store word
movi $r0 i8                   ; initialize constant into register
mul  $r0 $r0 $r1
add  $r0 $r4 $r0
addi $r1 $$locbase i128       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i96                ; call read_205
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i8         ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i192       ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r4 $$locbase $r0        ; copy memory with mem_copy
movi $r0 i40                  ; get length for mcp
mcp  $r2 $r4 $r0              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i312                     ; free 312 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for slot_calculator_204
cfei i368                     ; allocate 368 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r8 $$arg2               ; save arg 2 (__ret_value)
move $r7 $$reta               ; save reta
movi $r2 i8                   ; initialize constant into register
mul  $r2 $r1 $r2
movi $r3 i32                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i31                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i4                   ; initialize constant into register
mod  $r1 $r1 $r3
movi $r3 i8                   ; initialize constant into register
mul  $r3 $r1 $r3
movi $r4 i32                  ; initialize constant into register
add  $r3 $r3 $r4
movi $r4 i31                  ; initialize constant into register
add  $r3 $r3 $r4
movi $r4 i5                   ; initialize constant into register
srl  $r3 $r3 $r4
addi $r4 $$locbase i48        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r4 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i336       ; get offset to local
addi $r4 $$locbase i112       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4264              ; call as_u256_62
move $r2 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4272              ; call as_u256_62
move $r4 $$retv               ; copy the return value
addi $r5 $$locbase i176       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r2 $r6              ; copy memory with mem_copy
addi $r2 $$locbase i304       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r2 $r4 $r6              ; copy memory with mem_copy
addi $r4 $$locbase i240       ; get offset to local
wqop $r4 $r5 $r2 i33
addi $r2 $$locbase i208       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i240       ; get offset to local
addi $r4 $$locbase i272       ; get offset to local
wqop $r4 $r2 $r0 i32
addi $r0 $$locbase i336       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i80        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
sw   $$locbase $r3 i4         ; store word
sw   $$locbase $r1 i5         ; store word
movi $r0 i48                  ; get length for mcp
mcp  $r8 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r8               ; set return value
cfsi i368                     ; free 368 bytes for locals and 0 slots for extra call arguments.
move $$reta $r7               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_205
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for le_210
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (other)
move $r2 $$reta               ; save reta
lt   $r3 $r0 $r1
jnzf $r3 $zero i1
eq   $r3 $r0 $r1
move $$retv $r3               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for sha256_211
cfei i136                     ; allocate 136 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (s)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4267              ; call new_70
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i112       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i112       ; get offset to local
addi $r4 $$locbase i56        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4212              ; call hash_75
addi $r0 $$locbase i112       ; get offset to local
addi $r3 $$locbase i88        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3864              ; call sha256_94
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i136                     ; free 136 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for offset_calculator_212
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (offset)
move $r1 $$reta               ; save reta
movi $r2 i32                  ; initialize constant into register
mul  $r0 $r0 $r2
movi $r2 i8                   ; initialize constant into register
div  $r0 $r0 $r2
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for sha256_214
cfei i144                     ; allocate 144 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (s)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4327              ; call new_70
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i120       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i120       ; get offset to local
addi $r4 $$locbase i80        ; get offset to local
movi $r5 i40                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i20                ; call hash_215
addi $r0 $$locbase i120       ; get offset to local
addi $r3 $$locbase i56        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3924              ; call sha256_94
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i144                     ; free 144 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for hash_215
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (state)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i15                ; call hash_216
addi $r0 $r0 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4315              ; call hash_75
move $$retv $zero             ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for hash_216
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (state)
move $r2 $$reta               ; save reta
movi $r3 i8                   ; initialize constant into register
aloc $r3                      ; aloc size
move $r3 $hp                  ; return value from inline asm (hp)
sw   $r3 $r0 i0               ; sw ptr val i0
move $$arg0 $r3               ; pass arg 0
movi $r0 i8                   ; initialize constant into register
move $$arg1 $r0               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4122              ; call from_parts_82
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i64        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i16        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4029              ; call from_93
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i40        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4304              ; call write_76
move $$retv $zero             ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for write_218
cfei i192                     ; allocate 192 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r2 $$arg2               ; save arg 2 (value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i48        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i305               ; call slot_calculator_204
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i112       ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i112       ; get offset to local
addi $r1 $$locbase i160       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
lw   $r0 $$locbase i18        ; load word
lw   $r1 $$locbase i19        ; load word
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r0 $r4
movi $r5 i8                   ; initialize constant into register
mul  $r4 $r5 $r4
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
addi $r5 $$locbase i160       ; get offset to local
srwq $r4 $r5 $r5 $r0          ; access a sequence of storage slots
movi $r5 i8                   ; initialize constant into register
mul  $r1 $r5 $r1
add  $r1 $r4 $r1
addi $r5 $$locbase i80        ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r2 $r6              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i8                 ; call write_219
addi $r1 $$locbase i160       ; get offset to local
swwq $r1 $r0 $r4 $r0          ; access a sequence of storage slots
move $$retv $zero             ; set return value
cfsi i192                     ; free 192 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for write_219
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (val)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r1 $r3        ; copy memory with mem_copy
movi $r3 i32                  ; initialize constant into register
move $r1 $$locbase            ; copy const asm init to GP reg
mcp  $r0 $r1 $r3              ; mcp dst src count
move $$retv $zero             ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for write_220
cfei i160                     ; allocate 160 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r2 $$arg2               ; save arg 2 (value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i48        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i666               ; call slot_calculator_181
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i80        ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i80        ; get offset to local
addi $r1 $$locbase i128       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
lw   $r0 $$locbase i14        ; load word
lw   $r1 $$locbase i15        ; load word
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r0 $r4
movi $r5 i8                   ; initialize constant into register
mul  $r4 $r5 $r4
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
addi $r5 $$locbase i128       ; get offset to local
srwq $r4 $r5 $r5 $r0          ; access a sequence of storage slots
movi $r5 i8                   ; initialize constant into register
mul  $r1 $r5 $r1
add  $r1 $r4 $r1
sw   $r1 $r2 i0               ; sw ptr val i0
addi $r1 $$locbase i128       ; get offset to local
swwq $r1 $r0 $r4 $r0          ; access a sequence of storage slots
move $$retv $zero             ; set return value
cfsi i160                     ; free 160 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for insert_222
cfei i328                     ; allocate 328 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (key)
move $r2 $$arg2               ; save arg 2 (value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i224       ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i587               ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r1 $r4        ; copy memory with mem_copy
addi $r1 $$locbase i32        ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i128       ; get offset to local
movi $r1 i64                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i64        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4638              ; call sha256_69
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i296       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i296       ; get offset to local
addi $r1 $$locbase i192       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i95                ; call write_220
move $$retv $zero             ; set return value
cfsi i328                     ; free 328 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for insert_227
cfei i576                     ; allocate 576 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (key)
move $r5 $$arg2               ; save arg 2 (value)
move $r4 $$reta               ; save reta
addi $r2 $$locbase i392       ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i264       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i532               ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r1 $r2        ; copy memory with mem_copy
addi $r1 $$locbase i32        ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i328       ; get offset to local
movi $r1 i64                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i232       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4693              ; call sha256_69
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i512       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i512       ; get offset to local
addi $r1 $$locbase i296       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i184       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4821              ; call slot_calculator_54
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i464       ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i464       ; get offset to local
addi $r1 $$locbase i544       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i62        ; load word
lw   $r1 $$locbase i63        ; load word
movi $r2 i32                  ; initialize constant into register
mul  $r2 $r0 $r2
movi $r3 i8                   ; initialize constant into register
mul  $r2 $r3 $r2
aloc $r2                      ; aloc size
move $r2 $hp                  ; move ptr hp
addi $r3 $$locbase i544       ; get offset to local
srwq $r2 $r3 $r3 $r0          ; access a sequence of storage slots
movi $r3 i8                   ; initialize constant into register
mul  $r1 $r3 $r1
add  $r1 $r2 $r1
addi $r3 $$locbase i64        ; get offset to local
movi $r6 i120                 ; get length for mcp
mcp  $r3 $r5 $r6              ; copy memory with mem_copy
movi $r5 i120                 ; initialize constant into register
mcp  $r1 $r3 $r5              ; mcp dst src count
addi $r1 $$locbase i544       ; get offset to local
swwq $r1 $r0 $r2 $r0          ; access a sequence of storage slots
move $$retv $zero             ; set return value
cfsi i576                     ; free 576 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for transfer_230
cfei i392                     ; allocate 392 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (to)
move $r6 $$arg1               ; save arg 1 (asset_id)
move $r5 $$arg2               ; save arg 2 (amount)
move $r4 $$reta               ; save reta
addi $r1 $$locbase i128       ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i29
lw   $r0 $$locbase i16        ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r0 $$locbase i128       ; get offset to local
addi $r0 $r0 i8               ; get offset to element
addi $r1 $$locbase i360       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i296       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i232       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i169               ; call bits_238
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i64        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r6 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i96        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
tr   $r2 $r5 $r1              ; tr r3 r1 r2
jmpf $zero i110
addi $r0 $$locbase i128       ; get offset to local
addi $r0 $r0 i8               ; get offset to element
addi $r1 $$locbase i328       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i328       ; get offset to local
addi $r1 $$locbase i168       ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3518              ; call tx_type_110
move $r1 $$retv               ; copy the return value
lw   $r1 $r1 i0               ; load word
eq   $r2 $r1 $zero
jnzf $r2 $zero i6
eq   $r1 $r1 $one
jnzf $r1 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
gtf  $r1 $zero i260           ; get transaction field
jmpf $zero i1
gtf  $r1 $zero i6             ; get transaction field
move $r8 $zero                ; parameter from branch to block argument
lt   $r2 $r8 $r1
jnzf $r2 $zero i2
load $r0 data_27              ; literal instantiation
rvrt $r0
addi $r2 $$locbase i184       ; get offset to local
move $$arg0 $r8               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i81                ; call output_type_233
move $r2 $$retv               ; copy the return value
lw   $r2 $r2 i0               ; load word
movi $r3 i3                   ; initialize constant into register
eq   $r2 $r2 $r3
jnzf $r2 $zero i1
jmpf $zero i49
addi $r2 $$locbase i192       ; get offset to local
move $$arg0 $r8               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i68                ; call output_type_233
move $r2 $$retv               ; copy the return value
lw   $r2 $r2 i0               ; load word
eq   $r3 $r2 $zero
jnzf $r3 $zero i35
eq   $r3 $r2 $one
jnzf $r3 $zero i32
movi $r3 i2                   ; initialize constant into register
eq   $r3 $r2 $r3
move $r7 $zero                ; parameter from branch to block argument
jnzf $r3 $zero i27
movi $r3 i3                   ; initialize constant into register
eq   $r3 $r2 $r3
jnzf $r3 $zero i6
movi $r0 i4                   ; initialize constant into register
eq   $r0 $r2 $r0
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
rvrt $zero
addi $r2 $$locbase i176       ; get offset to local
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3579              ; call tx_type_110
move $r2 $$retv               ; copy the return value
lw   $r2 $r2 i0               ; load word
eq   $r3 $r2 $zero
jnzf $r3 $zero i6
eq   $r2 $r2 $one
jnzf $r2 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
gtf  $r2 $r8 i265             ; get transaction field
jmpf $zero i1
gtf  $r2 $r8 i12              ; get transaction field
lw   $r7 $r2 i5               ; lw r1 r2 i0
jmpf $zero i2
rvrt $zero
gtf  $r7 $r8 i770             ; get transaction field
eq   $r2 $r7 $zero
jnzf $r2 $zero i2
add  $r8 $r8 $one
jmpb $zero i66
addi $r1 $$locbase i264       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i200       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i58                ; call bits_238
move $r0 $$retv               ; copy the return value
movi $r1 i32                  ; get length for mcp
mcp  $$locbase $r0 $r1        ; copy memory with mem_copy
addi $r0 $$locbase i32        ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
move $r1 $$locbase            ; copy const asm init to GP reg
tro  $r1 $r8 $r5 $r0          ; tro r1 r2 r3 r4
move $$retv $zero             ; set return value
cfsi i392                     ; free 392 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for output_type_233
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (index)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
gtf  $r0 $r0 i768             ; get transaction field
eq   $r3 $r0 $zero
jnzf $r3 $zero i25
eq   $r3 $r0 $one
jnzf $r3 $zero i19
movi $r3 i2                   ; initialize constant into register
eq   $r3 $r0 $r3
jnzf $r3 $zero i12
movi $r3 i3                   ; initialize constant into register
eq   $r3 $r0 $r3
jnzf $r3 $zero i6
movi $r3 i4                   ; initialize constant into register
eq   $r0 $r0 $r3
jnzf $r0 $zero i1
rvrt $zero
movi $r3 i4                   ; initialize constant into register
jmpf $zero i1
movi $r3 i3                   ; initialize constant into register
addi $r0 $$locbase i8         ; get offset to local
jmpf $zero i2
addi $r0 $$locbase i8         ; get offset to local
movi $r3 i2                   ; initialize constant into register
addi $r0 $$locbase i16        ; get offset to local
jmpf $zero i2
addi $r0 $$locbase i16        ; get offset to local
move $r3 $one                 ; parameter from branch to block argument
addi $r0 $$locbase i24        ; get offset to local
jmpf $zero i2
addi $r0 $$locbase i24        ; get offset to local
move $r3 $zero                ; parameter from branch to block argument
sw   $r1 $r3 i0               ; store word
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for bits_238
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i2047                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for push_244
cfei i1152                    ; allocate 1152 bytes for locals and 0 slots for call arguments.
move $r6 $$arg0               ; save arg 0 (self)
move $r5 $$arg1               ; save arg 1 (value)
move $r4 $$reta               ; save reta
addi $r0 $$locbase i680       ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i472       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i233               ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i568       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i424       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1146              ; call read_180
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i600       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i983               ; call unwrap_or_196
move $r7 $$retv               ; copy the return value
addi $r0 $$locbase i752       ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i504       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i200               ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i616       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i440       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i717               ; call sha256_211
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1056      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i248                 ; initialize constant into register
mul  $r0 $r7 $r0
movi $r1 i8                   ; initialize constant into register
div  $r0 $r0 $r1
addi $r1 $$locbase i1056      ; get offset to local
movi $r2 i8                   ; initialize constant into register
mul  $r2 $r0 $r2
movi $r3 i248                 ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i31                  ; initialize constant into register
add  $r2 $r2 $r3
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i4                   ; initialize constant into register
mod  $r10 $r0 $r3
movi $r0 i8                   ; initialize constant into register
mul  $r0 $r10 $r0
movi $r3 i248                 ; initialize constant into register
add  $r0 $r0 $r3
movi $r3 i31                  ; initialize constant into register
add  $r0 $r0 $r3
movi $r3 i5                   ; initialize constant into register
srl  $r0 $r0 $r3
addi $r3 $$locbase i48        ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r3 $r1 $r8              ; copy memory with mem_copy
addi $r1 $$locbase i1120      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r1 $r3 $r8              ; copy memory with mem_copy
addi $r1 $$locbase i1120      ; get offset to local
addi $r3 $$locbase i360       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5092              ; call as_u256_62
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i392       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5100              ; call as_u256_62
move $r3 $$retv               ; copy the return value
addi $r8 $$locbase i896       ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r8 $r2 $r9              ; copy memory with mem_copy
addi $r2 $$locbase i1024      ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r2 $r3 $r9              ; copy memory with mem_copy
addi $r3 $$locbase i960       ; get offset to local
wqop $r3 $r8 $r2 i33
addi $r2 $$locbase i928       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i960       ; get offset to local
addi $r3 $$locbase i992       ; get offset to local
wqop $r3 $r2 $r1 i32
addi $r1 $$locbase i1120      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r3 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i80        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r3 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r1 $r2        ; copy memory with mem_copy
sw   $$locbase $r0 i4         ; store word
sw   $$locbase $r10 i5        ; store word
addi $r0 $$locbase i1088      ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
lw   $r0 $$locbase i4         ; load word
lw   $r1 $$locbase i5         ; load word
movi $r2 i32                  ; initialize constant into register
mul  $r2 $r0 $r2
movi $r3 i8                   ; initialize constant into register
mul  $r2 $r3 $r2
aloc $r2                      ; aloc size
move $r2 $hp                  ; move ptr hp
addi $r3 $$locbase i1088      ; get offset to local
srwq $r2 $r3 $r3 $r0          ; access a sequence of storage slots
movi $r3 i8                   ; initialize constant into register
mul  $r1 $r3 $r1
add  $r1 $r2 $r1
addi $r3 $$locbase i112       ; get offset to local
movi $r8 i248                 ; get length for mcp
mcp  $r3 $r5 $r8              ; copy memory with mem_copy
movi $r5 i248                 ; initialize constant into register
mcp  $r1 $r3 $r5              ; mcp dst src count
addi $r1 $$locbase i1088      ; get offset to local
swwq $r1 $r0 $r2 $r0          ; access a sequence of storage slots
addi $r0 $$locbase i824       ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i536       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i82                ; call field_id_251
move $r0 $$retv               ; copy the return value
add  $r1 $r7 $one
addi $r2 $$locbase i648       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i581               ; call write_220
move $$retv $zero             ; set return value
cfsi i1152                    ; free 1152 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i2047                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for get_250
cfei i432                     ; allocate 432 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (key)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i264       ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i46                ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r1 $r4        ; copy memory with mem_copy
addi $r1 $$locbase i32        ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i200       ; get offset to local
movi $r1 i64                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i64        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5179              ; call sha256_69
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i400       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i400       ; get offset to local
addi $r1 $$locbase i400       ; get offset to local
addi $r4 $$locbase i336       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i368       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i128       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $r1               ; pass arg 3
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i23                ; call new_252
move $r0 $$retv               ; copy the return value
movi $r1 i72                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i432                     ; free 432 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for field_id_251
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r0 $r0 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_252
cfei i72                      ; allocate 72 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slot)
move $r1 $$arg1               ; save arg 1 (offset)
move $r2 $$arg2               ; save arg 2 (field_id)
move $r3 $$arg3               ; save arg 3 (__ret_value)
move $r4 $$reta               ; save reta
movi $r5 i32                  ; get length for mcp
mcp  $$locbase $r0 $r5        ; copy memory with mem_copy
sw   $$locbase $r1 i4         ; store word
addi $r0 $$locbase i40        ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
movi $r0 i72                  ; get length for mcp
mcp  $r3 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r3               ; set return value
cfsi i72                      ; free 72 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for log_253
cfei i376                     ; allocate 376 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (value)
move $r1 $$reta               ; save reta
addi $r2 $$locbase i16        ; get offset to local
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5545              ; call new_39
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i104       ; get offset to local
movi $r4 i248                 ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i352       ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i56        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i28                ; call abi_encode_255
move $r0 $$retv               ; copy the return value
lw   $r2 $r0 i0               ; load word
lw   $r3 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r4 $$locbase i80        ; get offset to local
sw   $$locbase $r2 i10        ; store word
sw   $$locbase $r3 i11        ; store word
sw   $$locbase $r0 i12        ; store word
addi $r0 $$locbase i40        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5550              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
load $r0 data_28              ; literal instantiation
lw   $r2 $$locbase i0         ; load slice ptr
lw   $r3 $$locbase i1         ; load slice size
logd $zero $r0 $r2 $r3        ; log slice
move $$retv $zero             ; set return value
cfsi i376                     ; free 376 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_255
cfei i960                     ; allocate 960 bytes for locals and 0 slots for call arguments.
move $r8 $$arg0               ; save arg 0 (self)
move $r0 $$arg1               ; save arg 1 (buffer)
move $r7 $$arg2               ; save arg 2 (__ret_value)
move $r6 $$reta               ; save reta
addi $r1 $$locbase i680       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r8 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i712       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i184       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i227               ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r8 i32              ; get offset to element
movi $r4 i40                  ; get length for mcp
mcp  $$locbase $r3 $r4        ; copy memory with mem_copy
lw   $r3 $$locbase i0         ; load word
eq   $r3 $r3 $zero
jnzf $r3 $zero i46
lw   $r3 $$locbase i0         ; load word
eq   $r3 $r3 $one
jnzf $r3 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r3 $$locbase i8         ; get offset to element
addi $r4 $$locbase i928       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r4 $$locbase i328       ; get offset to local
sw   $$locbase $r1 i41        ; store word
sw   $$locbase $r2 i42        ; store word
sw   $$locbase $r0 i43        ; store word
addi $r0 $$locbase i64        ; get offset to local
move $$arg0 $one              ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5686              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r4 $$locbase i400       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i432       ; get offset to local
sw   $$locbase $r1 i54        ; store word
sw   $$locbase $r2 i55        ; store word
sw   $$locbase $r0 i56        ; store word
addi $r0 $$locbase i256       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i226               ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i824       ; get offset to local
jmpf $zero i40
addi $r3 $$locbase i8         ; get offset to element
addi $r4 $$locbase i896       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r4 $$locbase i304       ; get offset to local
sw   $$locbase $r1 i38        ; store word
sw   $$locbase $r2 i39        ; store word
sw   $$locbase $r0 i40        ; store word
addi $r0 $$locbase i40        ; get offset to local
move $$arg0 $zero             ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5727              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r4 $$locbase i792       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i376       ; get offset to local
sw   $$locbase $r1 i47        ; store word
sw   $$locbase $r2 i48        ; store word
sw   $$locbase $r0 i49        ; store word
addi $r0 $$locbase i232       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i185               ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i824       ; get offset to local
lw   $r0 $r8 i9               ; load word
addi $r4 $$locbase i352       ; get offset to local
sw   $$locbase $r1 i44        ; store word
sw   $$locbase $r2 i45        ; store word
sw   $$locbase $r3 i46        ; store word
addi $r1 $$locbase i88        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5764              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r3 $r8 i10              ; load word
eq   $r4 $r3 $zero
jnzf $r4 $zero i45
eq   $r4 $r3 $one
jnzf $r4 $zero i24
movi $r4 i2                   ; initialize constant into register
eq   $r3 $r3 $r4
jnzf $r3 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r3 $$locbase i656       ; get offset to local
sw   $$locbase $r1 i82        ; store word
sw   $$locbase $r2 i83        ; store word
sw   $$locbase $r0 i84        ; store word
addi $r0 $$locbase i160       ; get offset to local
movi $r1 i2                   ; initialize constant into register
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5791              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i848       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
jmpf $zero i17
addi $r3 $$locbase i632       ; get offset to local
sw   $$locbase $r1 i79        ; store word
sw   $$locbase $r2 i80        ; store word
sw   $$locbase $r0 i81        ; store word
addi $r0 $$locbase i136       ; get offset to local
move $$arg0 $one              ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5809              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i848       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i872       ; get offset to local
jmpf $zero i17
addi $r3 $$locbase i608       ; get offset to local
sw   $$locbase $r1 i76        ; store word
sw   $$locbase $r2 i77        ; store word
sw   $$locbase $r0 i78        ; store word
addi $r0 $$locbase i112       ; get offset to local
move $$arg0 $zero             ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5828              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i872       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $r8 i88              ; get offset to element
addi $r4 $$locbase i736       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i768       ; get offset to local
sw   $$locbase $r1 i96        ; store word
sw   $$locbase $r2 i97        ; store word
sw   $$locbase $r3 i98        ; store word
addi $r1 $$locbase i208       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i33                ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r8 i120             ; get offset to element
addi $r4 $$locbase i456       ; get offset to local
movi $r5 i128                 ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i584       ; get offset to local
sw   $$locbase $r1 i73        ; store word
sw   $$locbase $r2 i74        ; store word
sw   $$locbase $r0 i75        ; store word
addi $r0 $$locbase i280       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i96                ; call abi_encode_261
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
sw   $r7 $r1 i0               ; store word
sw   $r7 $r2 i1               ; store word
sw   $r7 $r0 i2               ; store word
move $$retv $r7               ; set return value
cfsi i960                     ; free 960 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_256
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i104       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i32                  ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
addi $r4 $$locbase i24        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r4 $r0 $r7              ; copy memory with mem_copy
add  $r0 $r6 $r1
movi $r7 i32                  ; get length for mcp
mcp  $r0 $r4 $r7              ; copy memory with mem_copy
movi $r0 i32                  ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i56        ; get offset to local
sw   $$locbase $r6 i7         ; store word
sw   $$locbase $r5 i8         ; store word
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i80        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_258
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i24        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i56        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r0 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i68                ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r4 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
sw   $r2 $r1 i0               ; store word
sw   $r2 $r4 i1               ; store word
sw   $r2 $r0 i2               ; store word
move $$retv $r2               ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_261
cfei i752                     ; allocate 752 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r7 $$arg2               ; save arg 2 (__ret_value)
move $r6 $$reta               ; save reta
movi $r2 i128                 ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $zero
jnzf $r0 $zero i139
lw   $r0 $$locbase i0         ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i2
load $r0 data_21              ; literal instantiation
rvrt $r0
addi $r0 $$locbase i8         ; get offset to element
addi $r2 $$locbase i632       ; get offset to local
movi $r3 i120                 ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i344       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i152       ; get offset to local
move $$arg0 $one              ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5998              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r8 $$locbase i632       ; get offset to local
addi $r3 $$locbase i416       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r8 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i448       ; get offset to local
sw   $$locbase $r1 i56        ; store word
sw   $$locbase $r2 i57        ; store word
sw   $$locbase $r0 i58        ; store word
addi $r0 $$locbase i224       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i134               ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r8 i32              ; get offset to element
addi $r4 $$locbase i472       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i504       ; get offset to local
sw   $$locbase $r1 i63        ; store word
sw   $$locbase $r2 i64        ; store word
sw   $$locbase $r0 i65        ; store word
addi $r0 $$locbase i248       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i105               ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r8 i64              ; get offset to element
addi $r4 $$locbase i528       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i560       ; get offset to local
sw   $$locbase $r1 i70        ; store word
sw   $$locbase $r2 i71        ; store word
sw   $$locbase $r0 i72        ; store word
addi $r0 $$locbase i272       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i125               ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r8 i96              ; get offset to element
lw   $r4 $r8 i12              ; load word
addi $r5 $$locbase i368       ; get offset to local
sw   $$locbase $r1 i46        ; store word
sw   $$locbase $r2 i47        ; store word
sw   $$locbase $r0 i48        ; store word
addi $r0 $$locbase i176       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6076              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r3 i8               ; get offset to element
lb   $r3 $r3 i0               ; load byte
addi $r4 $$locbase i584       ; get offset to local
sw   $$locbase $r1 i73        ; store word
sw   $$locbase $r2 i74        ; store word
sw   $$locbase $r0 i75        ; store word
addi $r0 $$locbase i296       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i48                ; call abi_encode_265
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r3 $r8 i14              ; load word
addi $r4 $$locbase i392       ; get offset to local
sw   $$locbase $r1 i49        ; store word
sw   $$locbase $r2 i50        ; store word
sw   $$locbase $r0 i51        ; store word
addi $r0 $$locbase i200       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6111              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
addi $r0 $$locbase i608       ; get offset to local
jmpf $zero i16
addi $r0 $$locbase i320       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i128       ; get offset to local
move $$arg0 $zero             ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6128              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i608       ; get offset to local
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r3 $r0 i2               ; load word
sw   $r7 $r1 i0               ; store word
sw   $r7 $r2 i1               ; store word
sw   $r7 $r3 i2               ; store word
move $$retv $r7               ; set return value
cfsi i752                     ; free 752 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_265
cfei i96                      ; allocate 96 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i72        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
add  $r4 $r1 $one
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
add  $r4 $r6 $r1
sb   $r4 $r0 i0               ; store byte
add  $r0 $r1 $one
addi $r1 $$locbase i24        ; get offset to local
sw   $$locbase $r6 i3         ; store word
sw   $$locbase $r5 i4         ; store word
sw   $$locbase $r0 i5         ; store word
addi $r0 $$locbase i48        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i96                      ; free 96 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for is_none_271
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
move $r2 $zero                ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r2 $one                 ; parameter from branch to block argument
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_278
cfei i104                     ; allocate 104 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i80        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i4                   ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
addi $r4 $$locbase i24        ; get offset to local
sw   $$locbase $r0 i3         ; store word
movi $r0 i4                   ; initialize constant into register
add  $r0 $r4 $r0
add  $r4 $r6 $r1
movi $r7 i4                   ; get length for mcp
mcp  $r4 $r0 $r7              ; copy memory with mem_copy
movi $r0 i4                   ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i32        ; get offset to local
sw   $$locbase $r6 i4         ; store word
sw   $$locbase $r5 i5         ; store word
sw   $$locbase $r0 i6         ; store word
addi $r0 $$locbase i56        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i104                     ; free 104 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for len_282
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i1               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_295
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slice)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i16        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i37                ; call len_297
move $r3 $$retv               ; copy the return value
movi $r4 i248                 ; initialize constant into register
mul  $r4 $r4 $r3
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
gt   $r5 $r3 $zero
jnzf $r5 $zero i1
jmpf $zero i11
movi $r5 i16                  ; get length for mcp
mcp  $$locbase $r0 $r5        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6571              ; call ptr_23
move $r5 $$retv               ; copy the return value
movi $r6 i248                 ; initialize constant into register
mul  $r6 $r3 $r6
mcp  $r4 $r5 $r6              ; mcp dst src len
addi $r5 $$locbase i32        ; get offset to local
movi $r6 i16                  ; get length for mcp
mcp  $r5 $r0 $r6              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10                ; call len_297
move $r0 $$retv               ; copy the return value
sw   $r1 $r4 i0               ; store word
sw   $r1 $r3 i1               ; store word
sw   $r1 $r0 i2               ; store word
move $$retv $r1               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for len_297
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i1               ; load word
movi $r2 i248                 ; initialize constant into register
div  $r0 $r0 $r2
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i65535                   ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for match_orders_311
cfei i8736                    ; allocate 8736 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (order_sell_id)
move $r1 $$arg1               ; save arg 1 (order_buy_id)
move $r7 $$reta               ; save reta
load $r2 data_5               ; get local constant
load $r3 data_5               ; get local constant
load $r4 data_5               ; get local constant
load $r5 data_5               ; get local constant
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6495              ; call reentrancy_guard_33
movi $r6 i32                  ; get length for mcp
mcp  $$locbase $r2 $r6        ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
addi $r2 $$locbase i40        ; get offset to element
movi $r6 i32                  ; get length for mcp
mcp  $r2 $r3 $r6              ; copy memory with mem_copy
movi $r2 i5256                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $$locbase $r3        ; copy memory with mem_copy
movi $r3 i5328                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r3 $r0 $r6              ; copy memory with mem_copy
addi $r0 $$locbase i1160      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i898               ; call get_250
move $r0 $$retv               ; copy the return value
movi $r2 i5464                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i2272      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6250              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r2 i8304                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i128                 ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i72        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r4 $r2              ; copy memory with mem_copy
sw   $$locbase $zero i13      ; store word
addi $r2 $r0 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r5 $r3              ; copy memory with mem_copy
movi $r2 i5360                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i5432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1232      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i938               ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i6448                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2400      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6290              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r1 i8056                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8304                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3120      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5252              ; call is_some_102
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i11
movi $r0 i8056                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3248      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5265              ; call is_some_102
move $r0 $$retv               ; copy the return value
movi $r1 i7376                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
sw   $$locbase $one i922      ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5622              ; call require_98
movi $r0 i8304                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3376      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2784      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5272              ; call unwrap_103
move $r0 $$retv               ; copy the return value
movi $r1 i8432                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8056                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3504      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2904      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5289              ; call unwrap_103
move $r0 $$retv               ; copy the return value
movi $r1 i8184                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
jnzf $r0 $zero i1
jmpf $zero i6
movi $r0 i8184                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
eq   $r0 $r0 $zero
addi $r1 $$locbase i3096      ; get offset to local
movi $r2 i4                   ; initialize constant into register
sw   $$locbase $r2 i387       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5678              ; call require_98
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i64              ; get offset to element
movi $r1 i8184                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i64              ; get offset to element
addi $r2 $$locbase i4072      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4512                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6422              ; call eq_50
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i1
jmpf $zero i9
lw   $r0 $$locbase i1068      ; load word
lw   $r1 $$locbase i1037      ; load word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1932              ; call le_210
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3104      ; get offset to local
movi $r2 i3                   ; initialize constant into register
sw   $$locbase $r2 i388       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5718              ; call require_98
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i8616                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4408                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i8432                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i16                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i1096      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2543              ; call flip_172
move $r0 $$retv               ; copy the return value
movi $r1 i8616                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r4 $$locbase i1066      ; load word
lw   $r0 $$locbase i1035      ; load word
lw   $r1 $$locbase i1037      ; load word
lw   $r2 $$locbase i1068      ; load word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4420              ; call mul_div_140
move $r0 $$retv               ; copy the return value
lt   $r1 $r4 $r0
jnzf $r1 $zero i1
move $r4 $r0                  ; parameter from branch to block argument
sw   $$locbase $r4 i1089      ; store word
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i32              ; get offset to element
movi $r1 i8552                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8616                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3632      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i880       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4839              ; call order_return_asset_amount_125
move $r0 $$retv               ; copy the return value
movi $r1 i7384                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i7384                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i8584                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r5 $$locbase i927       ; load word
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i8616                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i4136                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i120                 ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4256                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3831              ; call remove_update_order_internal_170
movi $r0 i8616                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i96              ; get offset to element
movi $r1 i4424                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1112      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2629              ; call flip_172
move $r0 $$retv               ; copy the return value
movi $r1 i8616                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8184                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i32              ; get offset to element
movi $r1 i7464                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8616                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3752      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i920       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4909              ; call order_return_asset_amount_125
move $r0 $$retv               ; copy the return value
movi $r1 i7424                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i40                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i7424                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i7496                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r10 $$locbase i932      ; load word
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i112             ; get offset to element
movi $r1 i8184                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i112             ; get offset to element
lw   $r2 $$locbase i1089      ; load word
addi $r3 $$locbase i3960      ; get offset to local
sw   $$locbase $zero i495     ; store word
sw   $$locbase $r2 i496       ; store word
addi $r2 $$locbase i992       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4387              ; call from_148
move $r2 $$retv               ; copy the return value
lw   $r0 $r0 i0               ; load word
addi $r3 $$locbase i3976      ; get offset to local
sw   $$locbase $zero i497     ; store word
sw   $$locbase $r0 i498       ; store word
addi $r0 $$locbase i1008      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4399              ; call from_148
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i3872      ; get offset to local
movi $r6 i16                  ; get length for mcp
mcp  $r3 $r2 $r6              ; copy memory with mem_copy
addi $r2 $$locbase i3912      ; get offset to local
movi $r6 i16                  ; get length for mcp
mcp  $r2 $r0 $r6              ; copy memory with mem_copy
addi $r0 $$locbase i960       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4472              ; call multiply_141
move $r0 $$retv               ; copy the return value
lw   $r2 $r0 i0               ; load word
lw   $r0 $r0 i1               ; load word
lw   $r1 $r1 i0               ; load word
addi $r3 $$locbase i3992      ; get offset to local
sw   $$locbase $zero i499     ; store word
sw   $$locbase $r1 i500       ; store word
addi $r1 $$locbase i1024      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4428              ; call from_148
move $r1 $$retv               ; copy the return value
lw   $r3 $r1 i0               ; load word
lw   $r1 $r1 i1               ; load word
addi $r6 $$locbase i4008      ; get offset to local
sw   $$locbase $r2 i501       ; store word
sw   $$locbase $r0 i502       ; store word
addi $r8 $$locbase i4024      ; get offset to local
sw   $$locbase $r3 i503       ; store word
sw   $$locbase $r1 i504       ; store word
addi $r9 $$locbase i1040      ; get offset to local
move $$arg0 $r6               ; pass arg 0
move $$arg1 $r8               ; pass arg 1
move $$arg2 $r9               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4430              ; call divide_149
move $r6 $$retv               ; copy the return value
lw   $r8 $r6 i0               ; load word
lw   $r6 $r6 i1               ; load word
addi $r9 $$locbase i3928      ; get offset to local
sw   $$locbase $r8 i491       ; store word
sw   $$locbase $r6 i492       ; store word
addi $r11 $$locbase i3944     ; get offset to local
sw   $$locbase $r3 i493       ; store word
sw   $$locbase $r1 i494       ; store word
addi $r1 $$locbase i976       ; get offset to local
move $$arg0 $r9               ; pass arg 0
move $$arg1 $r11              ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4520              ; call multiply_141
move $r1 $$retv               ; copy the return value
addi $r3 $$locbase i4040      ; get offset to local
movi $r9 i16                  ; get length for mcp
mcp  $r3 $r1 $r9              ; copy memory with mem_copy
addi $r1 $$locbase i4056      ; get offset to local
sw   $$locbase $r2 i507       ; store word
sw   $$locbase $r0 i508       ; store word
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4062              ; call lt_163
move $r0 $$retv               ; copy the return value
move $r1 $one                 ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r1 $zero                ; parameter from branch to block argument
movi $r0 i4120                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
sw   $$locbase $r8 i515       ; store word
sw   $$locbase $r6 i516       ; store word
addi $r2 $$locbase i1056      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4035              ; call as_u64_166
move $r0 $$retv               ; copy the return value
movi $r2 i4104                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4064              ; call unwrap_165
move $r0 $$retv               ; copy the return value
add  $r0 $r0 $r1
sw   $$locbase $r0 i1089      ; store word
movi $r0 i8184                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i8616                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r1 $r1 i96              ; get offset to element
movi $r2 i4272                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i120                 ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4392                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4034              ; call remove_update_order_internal_170
eq   $r0 $r5 $zero
eq   $r0 $r0 $zero
jnzf $r0 $zero i1
jmpf $zero i2
eq   $r0 $r10 $zero
eq   $r0 $r0 $zero
load $r15 data_5              ; get local constant
load $r14 data_5              ; get local constant
load $r13 data_14             ; get local constant
load $r12 data_14             ; get local constant
load $r11 data_5              ; get local constant
load $r9 data_5               ; get local constant
load $r8 data_14              ; get local constant
load $r6 data_14              ; get local constant
addi $r1 $$locbase i3112      ; get offset to local
movi $r2 i5                   ; initialize constant into register
sw   $$locbase $r2 i389       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6044              ; call require_98
addi $r0 $$locbase i536       ; get offset to local
sw   $$locbase $zero i67      ; store word
movi $r1 i8552                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $r0 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i8584                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4440                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i40                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4480                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r5               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1836              ; call transfer_230
addi $r0 $$locbase i576       ; get offset to local
sw   $$locbase $zero i72      ; store word
movi $r1 i7464                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $r0 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i7496                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4544                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i40                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4584                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r10              ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1860              ; call transfer_230
addi $r0 $$locbase i848       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5714              ; call msg_sender_address_104
move $r0 $$retv               ; copy the return value
movi $r1 i8024                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i616       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r15 $r2             ; copy memory with mem_copy
sw   $$locbase $zero i81      ; store word
addi $r2 $r1 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r14 $r3             ; copy memory with mem_copy
movi $r2 i8432                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i5536                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r3 $r1 $r5              ; copy memory with mem_copy
movi $r1 i5608                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r1 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i1304      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1496              ; call get_250
move $r1 $$retv               ; copy the return value
movi $r2 i6800                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i2528      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6848              ; call try_read_52
move $r1 $$retv               ; copy the return value
movi $r2 i6984                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i7016                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i128                 ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1776      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i462               ; call match_orders_314
move $r0 $$retv               ; copy the return value
movi $r1 i7528                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i688       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r13 $r1             ; copy memory with mem_copy
sw   $$locbase $zero i90      ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r12 $r2             ; copy memory with mem_copy
movi $r1 i8432                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i5640                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i5712                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1376      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1555              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i7528                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4616                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i4688                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i248                 ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1758              ; call push_244
movi $r0 i7528                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i5952                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1482              ; call log_253
movi $r0 i8184                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i144       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r11 $r2             ; copy memory with mem_copy
sw   $$locbase $zero i22      ; store word
addi $r2 $r1 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r9 $r3              ; copy memory with mem_copy
movi $r2 i8184                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i5744                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r3 $r1 $r5              ; copy memory with mem_copy
movi $r1 i5816                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r1 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i1448      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1610              ; call get_250
move $r1 $$retv               ; copy the return value
movi $r2 i7304                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i2656      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6962              ; call try_read_52
move $r1 $$retv               ; copy the return value
movi $r2 i7144                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i7176                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i128                 ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i2024      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i348               ; call match_orders_314
move $r0 $$retv               ; copy the return value
movi $r1 i7776                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i216       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r8 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i31      ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r6 $r2              ; copy memory with mem_copy
movi $r1 i8184                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i5848                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i5920                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1520      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1669              ; call get_250
move $r0 $$retv               ; copy the return value
movi $r1 i7776                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i4936                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
movi $r0 i5008                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r3 i248                 ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1872              ; call push_244
movi $r0 i7776                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r1 i6200                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i248                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1596              ; call log_253
movi $r0 i8432                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r0 $r0 i64              ; get offset to element
movi $r1 i8024                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i8432                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r2 $r2 i32              ; get offset to element
movi $r3 i8184                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
addi $r3 $r3 i32              ; get offset to element
movi $r5 i8432                ; get offset to local
add  $r5 $$locbase $r5        ; get offset to local
addi $r5 $r5 i112             ; get offset to element
movi $r6 i8432                ; get offset to local
add  $r6 $$locbase $r6        ; get offset to local
movi $r8 i8184                ; get offset to local
add  $r8 $$locbase $r8        ; get offset to local
bhei $r9                      ; bhei height
time $r9 $r9                  ; time timestamp height
move $r10 $zero               ; copy const asm init to GP reg
addi $r11 $$locbase i1128     ; get offset to local
move $$arg0 $r10              ; pass arg 0
move $$arg1 $r11              ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2596              ; call read_205
move $r10 $$retv              ; copy the return value
addi $r12 $$locbase i288      ; get offset to local
movi $r11 i32                 ; get length for mcp
mcp  $r12 $r0 $r11            ; copy memory with mem_copy
addi $r0 $r12 i32             ; get offset to element
movi $r11 i32                 ; get length for mcp
mcp  $r0 $r1 $r11             ; copy memory with mem_copy
addi $r0 $r12 i64             ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r0 $r12 i96             ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
sw   $$locbase $r4 i52        ; store word
addi $r0 $r12 i136            ; get offset to element
movi $r1 i8                   ; get length for mcp
mcp  $r0 $r5 $r1              ; copy memory with mem_copy
addi $r0 $r12 i144            ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r6 $r1              ; copy memory with mem_copy
addi $r0 $r12 i176            ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r8 $r1              ; copy memory with mem_copy
sw   $$locbase $r9 i62        ; store word
addi $r0 $r12 i216            ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r10 $r1             ; copy memory with mem_copy
addi $r0 $$locbase i1072      ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7192              ; call new_39
move $r0 $$retv               ; copy the return value
movi $r1 i6688                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r12 $r2             ; copy memory with mem_copy
movi $r2 i6720                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1680      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1321              ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r12 i32             ; get offset to element
movi $r4 i6744                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i6776                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i847       ; store word
sw   $$locbase $r2 i848       ; store word
sw   $$locbase $r0 i849       ; store word
addi $r0 $$locbase i1704      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1343              ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r12 i64             ; get offset to element
movi $r4 i6872                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i6904                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i863       ; store word
sw   $$locbase $r2 i864       ; store word
sw   $$locbase $r0 i865       ; store word
addi $r0 $$locbase i1728      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1365              ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r12 i96             ; get offset to element
movi $r4 i6928                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i6960                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i870       ; store word
sw   $$locbase $r2 i871       ; store word
sw   $$locbase $r0 i872       ; store word
addi $r0 $$locbase i1752      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1387              ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r3 $r12 i16             ; load word
addi $r4 $$locbase i3024      ; get offset to local
sw   $$locbase $r1 i378       ; store word
sw   $$locbase $r2 i379       ; store word
sw   $$locbase $r0 i380       ; store word
addi $r0 $$locbase i776       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7337              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r3 $r12 i17             ; load word
addi $r4 $$locbase i3048      ; get offset to local
sw   $$locbase $r1 i381       ; store word
sw   $$locbase $r2 i382       ; store word
sw   $$locbase $r0 i383       ; store word
addi $r0 $$locbase i800       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7354              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r12 i144            ; get offset to element
movi $r4 i6520                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i6552                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i819       ; store word
sw   $$locbase $r2 i820       ; store word
sw   $$locbase $r0 i821       ; store word
addi $r0 $$locbase i1592      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1492              ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r12 i176            ; get offset to element
movi $r4 i6576                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i6608                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i826       ; store word
sw   $$locbase $r2 i827       ; store word
sw   $$locbase $r0 i828       ; store word
addi $r0 $$locbase i1632      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1514              ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r3 $r12 i26             ; load word
addi $r4 $$locbase i3072      ; get offset to local
sw   $$locbase $r1 i384       ; store word
sw   $$locbase $r2 i385       ; store word
sw   $$locbase $r0 i386       ; store word
addi $r0 $$locbase i824       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7415              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $r12 i216            ; get offset to element
movi $r4 i6632                ; get offset to local
add  $r4 $$locbase $r4        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
movi $r3 i6664                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
sw   $$locbase $r1 i833       ; store word
sw   $$locbase $r2 i834       ; store word
sw   $$locbase $r0 i835       ; store word
addi $r0 $$locbase i1656      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1553              ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i3888      ; get offset to local
sw   $$locbase $r1 i486       ; store word
sw   $$locbase $r2 i487       ; store word
sw   $$locbase $r0 i488       ; store word
addi $r0 $$locbase i1616      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7382              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i760       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
load $r0 data_29              ; literal instantiation
lw   $r1 $$locbase i95        ; load slice ptr
lw   $r2 $$locbase i96        ; load slice size
logd $zero $r0 $r1 $r2        ; log slice
move $$retv $zero             ; set return value
cfsi i8736                    ; free 8736 bytes for locals and 0 slots for extra call arguments.
move $$reta $r7               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i65535                   ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for match_orders_314
cfei i416                     ; allocate 416 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (id)
move $r1 $$arg1               ; save arg 1 (order)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i288       ; get offset to local
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6187              ; call msg_sender_106
move $r4 $$retv               ; copy the return value
addi $r5 $$locbase i368       ; get offset to local
movi $r6 i48                  ; get length for mcp
mcp  $r5 $r4 $r6              ; copy memory with mem_copy
addi $r4 $$locbase i248       ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6220              ; call unwrap_105
move $r4 $$retv               ; copy the return value
bhei $r5                      ; bhei height
time $r5 $r5                  ; time timestamp height
move $r6 $zero                ; copy const asm init to GP reg
addi $r7 $$locbase i336       ; get offset to local
move $$arg0 $r6               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2894              ; call read_205
move $r6 $$retv               ; copy the return value
movi $r7 i32                  ; get length for mcp
mcp  $$locbase $r0 $r7        ; copy memory with mem_copy
addi $r0 $$locbase i32        ; get offset to element
movi $r7 i40                  ; get length for mcp
mcp  $r0 $r4 $r7              ; copy memory with mem_copy
sw   $$locbase $r5 i9         ; store word
movi $r0 i2                   ; initialize constant into register
sw   $$locbase $r0 i10        ; store word
addi $r0 $$locbase i88        ; get offset to element
movi $r4 i32                  ; get length for mcp
mcp  $r0 $r6 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i120       ; get offset to element
movi $r4 i128                 ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r0 i248                 ; get length for mcp
mcp  $r2 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i416                     ; free 416 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i4095                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_320
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7828              ; call read_8_bytes_21
move $r3 $$retv               ; copy the return value
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r4 $r3
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
move $r11 $zero               ; parameter from branch to block argument
move $r10 $zero               ; parameter from branch to block argument
move $r5 $r3                  ; parameter from branch to block argument
lt   $r6 $r11 $r3
jnzf $r6 $zero i5
sw   $r1 $r4 i0               ; store word
sw   $r1 $r5 i1               ; store word
sw   $r1 $r10 i2              ; store word
move $$retv $r1               ; set return value
jmpf $zero i71
move $$arg0 $r0               ; pass arg 0
move $$arg1 $$locbase         ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7882              ; call abi_decode_13
move $r6 $$retv               ; copy the return value
addi $r7 $$locbase i96        ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r7 $r6 $r8              ; copy memory with mem_copy
addi $r6 $$locbase i96        ; get offset to local
addi $r7 $$locbase i80        ; get offset to local
sw   $$locbase $r4 i10        ; store word
sw   $$locbase $r5 i11        ; store word
move $$arg0 $r7               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i57                ; call capacity_326
move $r7 $$retv               ; copy the return value
eq   $r7 $r10 $r7
jnzf $r7 $zero i1
jmpf $zero i24
eq   $r7 $r5 $zero
move $r8 $one                 ; parameter from branch to block argument
jnzf $r7 $zero i2
movi $r7 i2                   ; initialize constant into register
mul  $r8 $r7 $r5
gt   $r7 $r8 $r5
jnzf $r7 $zero i1
jmpf $zero i15
movi $r7 i32                  ; initialize constant into register
mul  $r7 $r7 $r8
aloc $r7                      ; aloc size
move $r7 $hp                  ; move ptr hp
gt   $r9 $r5 $zero
jnzf $r9 $zero i1
jmpf $zero i7
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
move $$arg2 $r5               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i42                ; call copy_to_329
move $r4 $r7                  ; parameter from branch to block argument
move $r5 $r8                  ; parameter from branch to block argument
addi $r7 $$locbase i32        ; get offset to local
sw   $$locbase $r4 i4         ; store word
sw   $$locbase $r5 i5         ; store word
move $$arg0 $r7               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6923              ; call ptr_87
move $r7 $$retv               ; copy the return value
movi $r8 i32                  ; initialize constant into register
mul  $r8 $r8 $r10
add  $r7 $r7 $r8
addi $r8 $$locbase i48        ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r8 $r6 $r9              ; copy memory with mem_copy
move $$arg0 $r7               ; pass arg 0
move $$arg1 $r8               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2748              ; call write_219
add  $r10 $r10 $one
add  $r11 $r11 $one
jmpb $zero i76
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i4095                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for capacity_326
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i1               ; load word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for copy_to_329
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (dst)
move $r2 $$arg2               ; save arg 2 (count)
move $r3 $$reta               ; save reta
movi $r4 i32                  ; initialize constant into register
mul  $r2 $r2 $r4
mcp  $r1 $r0 $r2              ; mcp dst src len
move $$retv $zero             ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for get_334
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (index)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
lw   $r4 $r0 i2               ; load word
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3048              ; call le_210
move $r4 $$retv               ; copy the return value
jnzf $r4 $zero i29
addi $r4 $$locbase i112       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6995              ; call ptr_87
move $r0 $$retv               ; copy the return value
movi $r4 i32                  ; initialize constant into register
mul  $r1 $r4 $r1
add  $r0 $r0 $r1
addi $r1 $$locbase i40        ; get offset to local
sw   $$locbase $one i5        ; store word
addi $r4 $$locbase i80        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3084              ; call read_205
move $r0 $$retv               ; copy the return value
addi $r4 $r1 i8               ; get offset to element
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
movi $r0 i40                  ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
move $$retv $r2               ; set return value
jmpf $zero i4
sw   $$locbase $zero i0       ; store word
movi $r0 i40                  ; get length for mcp
mcp  $r2 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for is_none_335
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
move $r2 $zero                ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r2 $one                 ; parameter from branch to block argument
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for sha256_351
cfei i168                     ; allocate 168 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (s)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7358              ; call new_70
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i144       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i144       ; get offset to local
addi $r4 $$locbase i80        ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3424              ; call hash_190
addi $r4 $r0 i32              ; get offset to element
addi $r5 $$locbase i112       ; get offset to local
movi $r6 i32                  ; get length for mcp
mcp  $r5 $r4 $r6              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3434              ; call hash_190
lw   $r0 $r0 i8               ; load word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2997              ; call hash_216
addi $r0 $$locbase i144       ; get offset to local
addi $r3 $$locbase i56        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6972              ; call sha256_94
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i168                     ; free 168 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_362
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i32        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i8150              ; call abi_decode_11
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_368
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (slice)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i16        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i41                ; call len_370
move $r3 $$retv               ; copy the return value
movi $r4 i32                  ; initialize constant into register
mul  $r4 $r4 $r3
aloc $r4                      ; aloc size
move $r4 $hp                  ; move ptr hp
gt   $r5 $r3 $zero
jnzf $r5 $zero i1
jmpf $zero i15
movi $r5 i16                  ; get length for mcp
mcp  $$locbase $r0 $r5        ; copy memory with mem_copy
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i8117              ; call ptr_23
move $r5 $$retv               ; copy the return value
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i209               ; call copy_to_329
addi $r5 $$locbase i32        ; get offset to local
movi $r6 i16                  ; get length for mcp
mcp  $r5 $r0 $r6              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i10                ; call len_370
move $r0 $$retv               ; copy the return value
sw   $r1 $r4 i0               ; store word
sw   $r1 $r3 i1               ; store word
sw   $r1 $r0 i2               ; store word
move $$retv $r1               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for len_370
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i1               ; load word
movi $r2 i32                  ; initialize constant into register
div  $r0 $r0 $r2
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i2047                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for create_market
cfei i1688                    ; allocate 1688 bytes for locals and 0 slots for call arguments.
move $r10 $$arg0              ; save arg 0 (asset_id)
move $r9 $$arg1               ; save arg 1 (asset_decimals)
move $r8 $$reta               ; save reta
load $r0 data_7               ; get local constant
load $r1 data_7               ; get local constant
load $r7 data_7               ; get local constant
load $r6 data_7               ; get local constant
addi $r2 $ssp i8              ; configurable QUOTE_TOKEN address
addi $r3 $$locbase i864       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r10 $r4             ; copy memory with mem_copy
addi $r4 $$locbase i1256      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7794              ; call eq_50
move $r2 $$retv               ; copy the return value
eq   $r2 $r2 $zero
addi $r3 $$locbase i1360      ; get offset to local
movi $r4 i7                   ; initialize constant into register
sw   $$locbase $r4 i170       ; store word
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7080              ; call require_98
addi $r2 $$locbase i64        ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
sw   $$locbase $zero i12      ; store word
addi $r0 $r2 i40              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i896       ; get offset to local
movi $r1 i72                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i968       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r10 $r2             ; copy memory with mem_copy
addi $r2 $$locbase i656       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3575              ; call get_198
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1504      ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i624       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3644              ; call slot_182
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i1288      ; get offset to local
movi $r3 i72                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7645              ; call offset_67
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i1376      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i496       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6049              ; call read_128
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1184      ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1800              ; call is_none_271
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1368      ; get offset to local
movi $r2 i6                   ; initialize constant into register
sw   $$locbase $r2 i171       ; store word
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7152              ; call require_98
addi $r0 $$locbase i136       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r10 $r1             ; copy memory with mem_copy
sw   $$locbase $r9 i21        ; store word
addi $r0 $$locbase i176       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r7 $r1              ; copy memory with mem_copy
sw   $$locbase $zero i26      ; store word
addi $r1 $r0 i40              ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r6 $r2              ; copy memory with mem_copy
addi $r4 $$locbase i136       ; get offset to local
addi $r1 $$locbase i1000      ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i760       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2476              ; call field_id_251
move $r0 $$retv               ; copy the return value
movi $r1 i32                  ; get length for mcp
mcp  $$locbase $r10 $r1       ; copy memory with mem_copy
addi $r1 $$locbase i32        ; get offset to element
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1440      ; get offset to local
movi $r1 i64                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i592       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i5963              ; call sha256_134
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1624      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1624      ; get offset to local
addi $r1 $$locbase i1408      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i544       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6060              ; call slot_calculator_129
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1576      ; get offset to local
movi $r2 i48                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1576      ; get offset to local
addi $r1 $$locbase i1656      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i201       ; load word
lw   $r1 $$locbase i202       ; load word
movi $r2 i32                  ; initialize constant into register
mul  $r2 $r0 $r2
movi $r3 i8                   ; initialize constant into register
mul  $r2 $r3 $r2
aloc $r2                      ; aloc size
move $r2 $hp                  ; move ptr hp
addi $r3 $$locbase i1656      ; get offset to local
srwq $r2 $r3 $r3 $r0          ; access a sequence of storage slots
movi $r3 i8                   ; initialize constant into register
mul  $r1 $r3 $r1
add  $r1 $r2 $r1
addi $r3 $$locbase i328       ; get offset to local
movi $r5 i40                  ; get length for mcp
mcp  $r3 $r4 $r5              ; copy memory with mem_copy
movi $r4 i40                  ; initialize constant into register
mcp  $r1 $r3 $r4              ; mcp dst src count
addi $r1 $$locbase i1656      ; get offset to local
swwq $r1 $r0 $r2 $r0          ; access a sequence of storage slots
bhei $r0                      ; bhei height
time $r0 $r0                  ; time timestamp height
move $r1 $zero                ; copy const asm init to GP reg
addi $r2 $$locbase i728       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3481              ; call read_205
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i248       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r10 $r3             ; copy memory with mem_copy
sw   $$locbase $r9 i35        ; store word
sw   $$locbase $r0 i36        ; store word
addi $r0 $r2 i48              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i408       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i8059              ; call new_39
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1128      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i1160      ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i448       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2186              ; call abi_encode_258
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r3 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r4 $r2 i4               ; load word
addi $r5 $$locbase i1232      ; get offset to local
sw   $$locbase $r1 i154       ; store word
sw   $$locbase $r3 i155       ; store word
sw   $$locbase $r0 i156       ; store word
addi $r0 $$locbase i472       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1934              ; call abi_encode_278
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r3 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
lw   $r4 $r2 i5               ; load word
addi $r5 $$locbase i816       ; get offset to local
sw   $$locbase $r1 i102       ; store word
sw   $$locbase $r3 i103       ; store word
sw   $$locbase $r0 i104       ; store word
addi $r0 $$locbase i384       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i8153              ; call abi_encode_38
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r3 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r2 $r2 i48              ; get offset to element
addi $r4 $$locbase i1072      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i1104      ; get offset to local
sw   $$locbase $r1 i138       ; store word
sw   $$locbase $r3 i139       ; store word
sw   $$locbase $r0 i140       ; store word
addi $r0 $$locbase i792       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2289              ; call abi_encode_256
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i840       ; get offset to local
sw   $$locbase $r1 i105       ; store word
sw   $$locbase $r2 i106       ; store word
sw   $$locbase $r0 i107       ; store word
addi $r0 $$locbase i432       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i8118              ; call as_raw_slice_40
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i368       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
load $r0 data_30              ; literal instantiation
lw   $r1 $$locbase i46        ; load slice ptr
lw   $r2 $$locbase i47        ; load slice size
logd $zero $r0 $r1 $r2        ; log slice
move $$retv $zero             ; set return value
cfsi i1688                    ; free 1688 bytes for locals and 0 slots for extra call arguments.
move $$reta $r8               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i2047                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for get_market_by_id
cfei i592                     ; allocate 592 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (asset_id)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
load $r3 data_7               ; get local constant
load $r4 data_7               ; get local constant
movi $r5 i32                  ; get length for mcp
mcp  $$locbase $r3 $r5        ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
addi $r3 $$locbase i40        ; get offset to element
movi $r5 i32                  ; get length for mcp
mcp  $r3 $r4 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i488       ; get offset to local
movi $r4 i72                  ; get length for mcp
mcp  $r3 $$locbase $r4        ; copy memory with mem_copy
addi $r4 $$locbase i560       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i192       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3862              ; call get_198
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i416       ; get offset to local
movi $r4 i72                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i160       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3931              ; call slot_182
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i264       ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
move $$arg0 $r4               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i7932              ; call offset_67
move $r0 $$retv               ; copy the return value
addi $r4 $$locbase i384       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i112       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6336              ; call read_128
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i336       ; get offset to local
movi $r4 i48                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i72        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i6369              ; call unwrap_126
move $r0 $$retv               ; copy the return value
movi $r3 i40                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i592                     ; free 592 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for get_order_change_events_by_order
cfei i696                     ; allocate 696 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (order)
move $r7 $$arg1               ; save arg 1 (__ret_value)
move $r6 $$reta               ; save reta
load $r1 data_14              ; get local constant
load $r2 data_14              ; get local constant
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r1 $r3        ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
addi $r1 $$locbase i40        ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i376       ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $$locbase $r2        ; copy memory with mem_copy
addi $r2 $$locbase i448       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i136       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2837              ; call get_250
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i480       ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i208       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2784              ; call field_id_251
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i296       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i88        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4165              ; call read_180
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i328       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4002              ; call unwrap_or_196
move $r1 $$retv               ; copy the return value
eq   $r2 $r1 $zero
jnzf $r2 $zero i55
movi $r2 i248                 ; initialize constant into register
mul  $r1 $r1 $r2
movi $r2 i31                  ; initialize constant into register
add  $r2 $r1 $r2
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i32                  ; initialize constant into register
mul  $r3 $r2 $r3
aloc $r3                      ; aloc size
move $r3 $hp                  ; return value from inline asm (hp)
addi $r4 $$locbase i552       ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i240       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2829              ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r4 $$locbase i344       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i104       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3748              ; call sha256_211
move $r0 $$retv               ; copy the return value
addi $r4 $$locbase i664       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
srwq $r3 $r0 $r4 $r2          ; access a sequence of storage slots
addi $r0 $$locbase i72        ; get offset to local
sw   $$locbase $r3 i9         ; store word
sw   $$locbase $r1 i10        ; store word
addi $r1 $$locbase i624       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i272       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2133              ; call from_295
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i640       ; get offset to local
lw   $r2 $r0 i0               ; load word
lw   $r1 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
jmpf $zero i6
move $r0 $zero                ; copy const asm init to GP reg
aloc $r0                      ; aloc size
move $r2 $hp                  ; move ptr hp
addi $r0 $$locbase i640       ; get offset to local
move $r0 $zero                ; parameter from branch to block argument
move $r1 $zero                ; parameter from branch to block argument
sw   $r7 $r2 i0               ; store word
sw   $r7 $r1 i1               ; store word
sw   $r7 $r0 i2               ; store word
move $$retv $r7               ; set return value
cfsi i696                     ; free 696 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for order_by_id
cfei i448                     ; allocate 448 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (order)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
load $r3 data_5               ; get local constant
load $r4 data_5               ; get local constant
movi $r5 i32                  ; get length for mcp
mcp  $$locbase $r3 $r5        ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
addi $r3 $$locbase i40        ; get offset to element
movi $r5 i32                  ; get length for mcp
mcp  $r3 $r4 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i344       ; get offset to local
movi $r4 i72                  ; get length for mcp
mcp  $r3 $$locbase $r4        ; copy memory with mem_copy
addi $r4 $$locbase i416       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i200       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r4               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2974              ; call get_250
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i272       ; get offset to local
movi $r4 i72                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i72        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i8325              ; call try_read_52
move $r0 $$retv               ; copy the return value
movi $r3 i128                 ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i448                     ; free 448 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for orders_by_trader
cfei i696                     ; allocate 696 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (trader)
move $r7 $$arg1               ; save arg 1 (__ret_value)
move $r6 $$reta               ; save reta
load $r1 data_12              ; get local constant
load $r2 data_12              ; get local constant
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r1 $r3        ; copy memory with mem_copy
sw   $$locbase $zero i4       ; store word
addi $r1 $$locbase i40        ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i344       ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $$locbase $r2        ; copy memory with mem_copy
addi $r2 $$locbase i416       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i104       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4133              ; call get_198
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i480       ; get offset to local
movi $r2 i72                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i208       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i2972              ; call field_id_251
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i296       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i88        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4353              ; call read_180
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i328       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
move $$arg1 $zero             ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i4190              ; call unwrap_or_196
move $r1 $$retv               ; copy the return value
eq   $r2 $r1 $zero
jnzf $r2 $zero i55
movi $r2 i32                  ; initialize constant into register
mul  $r1 $r1 $r2
movi $r2 i31                  ; initialize constant into register
add  $r2 $r1 $r2
movi $r3 i5                   ; initialize constant into register
srl  $r2 $r2 $r3
movi $r3 i32                  ; initialize constant into register
mul  $r3 $r2 $r3
aloc $r3                      ; aloc size
move $r3 $hp                  ; return value from inline asm (hp)
addi $r4 $$locbase i552       ; get offset to local
movi $r5 i72                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i240       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3017              ; call field_id_251
move $r0 $$retv               ; copy the return value
addi $r4 $$locbase i448       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i176       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i3936              ; call sha256_211
move $r0 $$retv               ; copy the return value
addi $r4 $$locbase i664       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
srwq $r3 $r0 $r4 $r2          ; access a sequence of storage slots
addi $r0 $$locbase i72        ; get offset to local
sw   $$locbase $r3 i9         ; store word
sw   $$locbase $r1 i10        ; store word
addi $r1 $$locbase i624       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i272       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i775               ; call from_368
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i640       ; get offset to local
lw   $r2 $r0 i0               ; load word
lw   $r1 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
jmpf $zero i6
move $r0 $zero                ; copy const asm init to GP reg
aloc $r0                      ; aloc size
move $r2 $hp                  ; move ptr hp
addi $r0 $$locbase i640       ; get offset to local
move $r0 $zero                ; parameter from branch to block argument
move $r1 $zero                ; parameter from branch to block argument
sw   $r7 $r2 i0               ; store word
sw   $r7 $r1 i1               ; store word
sw   $r7 $r0 i2               ; store word
move $$retv $r7               ; set return value
cfsi i696                     ; free 696 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
.data:
data_0 .bytes[4] 00 00 00 09  ....
data_1 .bytes[32] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
data_2 .bytes[4] 00 00 00 09  ....
data_3 .word 4294967295
data_4 .bytes[12] 63 61 6e 63 65 6c 5f 6f 72 64 65 72  cancel_order
data_5 .bytes[32] a2 4f a5 aa e3 19 77 e9 7e 8b d7 99 a1 a2 8e c9 7f 5f b7 d3 55 48 19 56 82 d9 5c 7c b1 14 8f c5  .O....w.~........_..UH.V..\|....
data_6 .bytes[13] 6d 61 72 6b 65 74 5f 65 78 69 73 74 73  market_exists
data_7 .bytes[32] ad 2f 32 0b 9f 3c f0 bd de 58 c7 df 14 45 72 88 06 ab 77 6c e0 ed 77 53 50 99 99 ea 5c 45 a7 4f  ./2..<...X...Er...wl..wSP...\E.O
data_8 .bytes[12] 6d 61 74 63 68 5f 6f 72 64 65 72 73  match_orders
data_9 .bytes[17] 6d 61 74 63 68 5f 6f 72 64 65 72 73 5f 6d 61 6e 79  match_orders_many
data_10 .bytes[10] 6f 70 65 6e 5f 6f 72 64 65 72  open_order
data_11 .bytes[32] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
data_12 .bytes[32] fc 86 33 bb c7 b1 8e 1e f6 8b a2 bb 06 78 35 9f f3 61 43 34 32 07 06 e4 46 7b 15 2d 3e b5 19 cd  ..3..........x5..aC42...F{.->...
data_13 .bytes[32] 38 ee 99 4e c1 5c 41 2a 03 6e b0 0d f5 3c 08 55 7d 54 78 f6 d9 ec 85 9e d2 19 d3 3e 26 e5 61 fe  8..N.\A*.n...<.U}Tx........>&.a.
data_14 .bytes[32] 4e 71 90 40 5f 6e ba 12 64 be 8e f1 c2 76 84 6b cd 18 57 89 28 76 43 8e 04 3f 83 53 23 ce 47 4c  Nq.@_n..d....v.k..W.(vC..?.S#.GL
data_15 .bytes[11] 6f 72 64 65 72 5f 62 79 5f 69 64  order_by_id
data_16 .bytes[16] 6f 72 64 65 72 73 5f 62 79 5f 74 72 61 64 65 72  orders_by_trader
data_17 .bytes[13] 63 72 65 61 74 65 5f 6d 61 72 6b 65 74  create_market
data_18 .bytes[17] 67 65 74 5f 63 6f 6e 66 69 67 75 72 61 62 6c 65 73  get_configurables
data_19 .bytes[16] 67 65 74 5f 6d 61 72 6b 65 74 5f 62 79 5f 69 64  get_market_by_id
data_20 .bytes[32] 67 65 74 5f 6f 72 64 65 72 5f 63 68 61 6e 67 65 5f 65 76 65 6e 74 73 5f 62 79 5f 6f 72 64 65 72  get_order_change_events_by_order
data_21 .word 14757395258967588866
data_22 .word 5557842539076482339
data_23 .word 18446744073709486080
data_24 .word 5432468599230875534
data_25 .word 18446744073709486084
data_26 .word 18446744073709551615
data_27 .word 18446744073709486081
data_28 .word 6411998037120698508
data_29 .word 8794783797310168923
data_30 .word 4834916382903929744


   [1;32mCompiling[0m script [1mmatch-script[0m (/home/kebradalaonda/p/compolabs-orderbook-contract/match-script)
;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i2
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i32                      ; stack space for globals
addr $$arg0 data_0            ; ptr to ORDER_BOOK_CONTRACT_ID default value
addi $$arg1 $zero i32         ; length of ORDER_BOOK_CONTRACT_ID default value
addi $$arg2 $ssp i0           ; ptr to global ORDER_BOOK_CONTRACT_ID stack address
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4
jmpf $zero i142               ; decode ORDER_BOOK_CONTRACT_ID
move $$locbase $sp            ; save locals base register for __entry
cfei i368                     ; allocate 368 bytes for locals and 0 slots for call arguments.
addi $r5 $$locbase i192       ; get offset to local
gtf  $r0 $zero i10            ; get transaction field
sw   $$locbase $r0 i38        ; store word
addi $r6 $$locbase i304       ; get offset to local
addi $r0 $$locbase i88        ; get offset to local
move $$arg0 $r6               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i181               ; call abi_decode_2
move $r7 $$retv               ; copy the return value
move $$arg0 $r6               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i197               ; call abi_decode_8
move $r4 $$retv               ; copy the return value
movi $r0 i32                  ; initialize constant into register
mul  $r0 $r0 $r4
aloc $r0                      ; aloc size
move $r0 $hp                  ; move ptr hp
sw   $$locbase $r0 i43        ; store word
sw   $$locbase $r4 i44        ; store word
sw   $$locbase $zero i45      ; store word
move $r8 $zero                ; parameter from branch to block argument
lt   $r0 $r8 $r4
jnzf $r0 $zero i46
addi $r0 $$locbase i344       ; get offset to local
movi $r1 i32                  ; get length for mcp
mcp  $$locbase $r7 $r1        ; copy memory with mem_copy
addi $r1 $$locbase i32        ; get offset to element
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i32        ; get offset to element
addi $r1 $$locbase i224       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $$locbase $r2        ; copy memory with mem_copy
addi $r2 $$locbase i256       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i194               ; call main_26
addi $r0 $$locbase i152       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i879               ; call new_32
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i280       ; get offset to local
sw   $$locbase $r1 i35        ; store word
sw   $$locbase $r2 i36        ; store word
sw   $$locbase $r0 i37        ; store word
addi $r0 $$locbase i176       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i889               ; call as_raw_slice_33
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r5 $r0 $r1              ; copy memory with mem_copy
lw   $r0 $r5 i1               ; load size of returned slice
lw   $r5 $r5 i0               ; load ptr of returned slice
retd  $r5 $r0
addi $r0 $$locbase i120       ; get offset to local
move $$arg0 $r6               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i111               ; call abi_decode_2
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i312       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r3 $$locbase i344       ; get offset to local
addi $r9 $$locbase i312       ; get offset to local
lw   $r0 $$locbase i45        ; load word
lw   $r1 $$locbase i44        ; load word
eq   $r0 $r0 $r1
jnzf $r0 $zero i1
jmpf $zero i25
lw   $r0 $r3 i1               ; load word
eq   $r0 $r0 $zero
move $r2 $one                 ; parameter from branch to block argument
jnzf $r0 $zero i3
lw   $r0 $r3 i1               ; load word
movi $r1 i2                   ; initialize constant into register
mul  $r2 $r1 $r0
lw   $r10 $r3 i0              ; load word
lw   $r11 $r3 i1              ; load word
gt   $r0 $r2 $r11
jnzf $r0 $zero i1
jmpf $zero i11
movi $r0 i32                  ; initialize constant into register
mul  $r0 $r0 $r2
aloc $r0                      ; aloc size
move $r0 $hp                  ; move ptr hp
gt   $r1 $r11 $zero
jnzf $r1 $zero i1
jmpf $zero i3
movi $r1 i32                  ; initialize constant into register
mul  $r1 $r11 $r1
mcp  $r0 $r10 $r1             ; mcp dst src len
move $r10 $r0                 ; parameter from branch to block argument
sw   $r3 $r10 i0              ; store word
sw   $r3 $r2 i1               ; store word
addi $r0 $$locbase i208       ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i105               ; call ptr_23
move $r0 $$retv               ; copy the return value
lw   $r1 $r3 i2               ; load word
movi $r2 i32                  ; initialize constant into register
mul  $r1 $r2 $r1
add  $r0 $r0 $r1
addi $r1 $$locbase i56        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r9 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; initialize constant into register
mcp  $r0 $r1 $r2              ; mcp dst src count
lw   $r0 $r3 i2               ; load word
add  $r0 $r0 $one
sw   $r3 $r0 i2               ; store word
add  $r8 $r8 $one
jmpb $zero i112
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_in_place_0
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg1               ; save arg 1 (len)
move $r3 $$arg2               ; save arg 2 (target)
move $r4 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i25                ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i40        ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i40        ; get offset to local
addi $r1 $$locbase i8         ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i25                ; call abi_decode_2
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i48        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i48        ; get offset to local
movi $r1 i32                  ; initialize constant into register
mcp  $r3 $r0 $r1              ; mcp target temp size
move $$retv $zero             ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_parts_1
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg2               ; save arg 2 (__ret_value)
move $r2 $$reta               ; save reta
sw   $r1 $r0 i0               ; store word
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_2
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r3 $r4        ; copy memory with mem_copy
lw   $r3 $r0 i0               ; load word
movi $r4 i32                  ; initialize constant into register
add  $r3 $r3 $r4
sw   $r0 $r3 i0               ; store word
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_8
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$reta               ; save reta
lw   $r2 $r0 i0               ; load word
lw   $r2 $r2 i0               ; lw val ptr i0
lw   $r3 $r0 i0               ; load word
movi $r4 i8                   ; initialize constant into register
add  $r3 $r3 $r4
sw   $r0 $r3 i0               ; store word
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_23
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i4095                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for main_26
cfei i3112                    ; allocate 3096 bytes for locals and 2 slots for call arguments.
move $r8 $$arg0               ; save arg 0 (order_id)
move $r7 $$arg1               ; save arg 1 (orders)
move $r6 $$reta               ; save reta
load $r0 data_1               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
sw   $$locbase $r0 i0         ; store word
movi $r0 i11                  ; initialize constant into register
sw   $$locbase $r0 i1         ; store word
addi $r0 $$locbase i56        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r0 $$locbase $r3        ; copy memory with mem_copy
addi $r3 $$locbase i256       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r8 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i2336      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i2368      ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r2 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i2384      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i2416      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r3 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i864       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r3               ; pass arg 4
load $r0 data_4               ; literal instantiation
sw   $$locbase $r0 i387       ; Pass arg 5 via its stack slot
sw   $$locbase $r1 i388       ; Pass arg 6 via its stack slot
addi $$arg5 $$locbase i3096   ; Save address of stack arguments in last arg register
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i345               ; call contract_call_29
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1264      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i504       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i312               ; call unwrap_27
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2600      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2600      ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r10 $r0 i0              ; load byte
move $r9 $zero                ; parameter from branch to block argument
lw   $r0 $r7 i2               ; load word
lt   $r0 $r9 $r0
jnzf $r0 $zero i2
move $$retv $zero             ; set return value
jmpf $zero i293
lw   $r0 $r7 i2               ; load word
lt   $r1 $r0 $r9
jnzf $r1 $zero i1
eq   $r1 $r0 $r9
jnzf $r1 $zero i21
addi $r0 $$locbase i1248      ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r7 $r1              ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i94                ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i32                  ; initialize constant into register
mul  $r1 $r1 $r9
add  $r0 $r0 $r1
addi $r1 $$locbase i216       ; get offset to local
sw   $$locbase $one i27       ; store word
addi $r2 $r1 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i2528      ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i5
addi $r0 $$locbase i16        ; get offset to local
sw   $$locbase $zero i2       ; store word
addi $r2 $$locbase i2528      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
addi $r0 $$locbase i464       ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
lw   $r0 $$locbase i316       ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
load $r0 data_1               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $$locbase i464       ; get offset to local
addi $r2 $r2 i8               ; get offset to element
addi $r3 $$locbase i2568      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r3 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r4 $$locbase i288       ; get offset to local
sw   $$locbase $r0 i36        ; store word
movi $r0 i11                  ; initialize constant into register
sw   $$locbase $r0 i37        ; store word
addi $r0 $$locbase i304       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r0 $r4 $r5              ; copy memory with mem_copy
addi $r4 $$locbase i320       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i2448      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r2 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i2480      ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r3 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i2496      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r4 $r5              ; copy memory with mem_copy
addi $r4 $$locbase i1520      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i992       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_4               ; literal instantiation
sw   $$locbase $r0 i387       ; Pass arg 5 via its stack slot
sw   $$locbase $r1 i388       ; Pass arg 6 via its stack slot
addi $$arg5 $$locbase i3096   ; Save address of stack arguments in last arg register
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i236               ; call contract_call_29
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2968      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2968      ; get offset to local
addi $r1 $$locbase i1664      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i794               ; call is_none_62
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i192
addi $r0 $$locbase i2968      ; get offset to local
addi $r1 $$locbase i1392      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i624       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i188               ; call unwrap_27
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2848      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2848      ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
move $r1 $r10                 ; parameter from branch to block argument
jnzf $r10 $zero i1
jmpf $zero i1
eq   $r1 $r0 $zero
jnzf $r1 $zero i50
eq   $r1 $r10 $zero
jnzf $r1 $zero i1
jmpf $zero i1
move $r1 $r0                  ; parameter from branch to block argument
jnzf $r1 $zero i1
jmpf $zero i43
load $r0 data_3               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i448       ; get offset to local
sw   $$locbase $r0 i56        ; store word
movi $r0 i12                  ; initialize constant into register
sw   $$locbase $r0 i57        ; store word
addi $r0 $$locbase i72        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i2848      ; get offset to local
addi $r4 $$locbase i2600      ; get offset to local
addi $r5 $$locbase i88        ; get offset to local
movi $r11 i32                 ; get length for mcp
mcp  $r5 $r3 $r11             ; copy memory with mem_copy
addi $r3 $r5 i32              ; get offset to element
movi $r11 i32                 ; get length for mcp
mcp  $r3 $r4 $r11             ; copy memory with mem_copy
addi $r3 $$locbase i2192      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i2224      ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i2240      ; get offset to local
movi $r4 i64                  ; get length for mcp
mcp  $r0 $r5 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i2304      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_4               ; literal instantiation
move $$arg5 $r0               ; pass arg 5
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i734               ; call contract_call_64
jmpf $zero i43
load $r0 data_3               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i352       ; get offset to local
sw   $$locbase $r0 i44        ; store word
movi $r0 i12                  ; initialize constant into register
sw   $$locbase $r0 i45        ; store word
addi $r0 $$locbase i368       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i2600      ; get offset to local
addi $r4 $$locbase i2848      ; get offset to local
addi $r5 $$locbase i384       ; get offset to local
movi $r11 i32                 ; get length for mcp
mcp  $r5 $r3 $r11             ; copy memory with mem_copy
addi $r3 $r5 i32              ; get offset to element
movi $r11 i32                 ; get length for mcp
mcp  $r3 $r4 $r11             ; copy memory with mem_copy
addi $r3 $$locbase i1920      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i1952      ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i1968      ; get offset to local
movi $r4 i64                  ; get length for mcp
mcp  $r0 $r5 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i2160      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_4               ; literal instantiation
move $$arg5 $r0               ; pass arg 5
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i690               ; call contract_call_64
load $r0 data_1               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i152       ; get offset to local
sw   $$locbase $r0 i19        ; store word
movi $r0 i11                  ; initialize constant into register
sw   $$locbase $r0 i20        ; store word
addi $r0 $$locbase i168       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i184       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r8 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i1552      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i1584      ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r2 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i1600      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i1632      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r3 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i1120      ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r3               ; pass arg 4
load $r0 data_4               ; literal instantiation
sw   $$locbase $r0 i387       ; Pass arg 5 via its stack slot
sw   $$locbase $r1 i388       ; Pass arg 6 via its stack slot
addi $$arg5 $$locbase i3096   ; Save address of stack arguments in last arg register
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i63                ; call contract_call_29
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2720      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i2720      ; get offset to local
addi $r1 $$locbase i1792      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i621               ; call is_none_62
move $r0 $$retv               ; copy the return value
jnzf $r0 $zero i17
addi $r0 $$locbase i2720      ; get offset to local
addi $r1 $$locbase i2032      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i744       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i15                ; call unwrap_27
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2600      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
add  $r9 $r9 $one
jmpb $zero i292
move $$retv $zero             ; set return value
jmpf $zero i2
add  $r9 $r9 $one
jmpb $zero i296
cfsi i3112                    ; free 3096 bytes for locals and 2 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i4095                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_27
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i128                 ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i120                 ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i2047                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for contract_call_29
cfei i1000                    ; allocate 1000 bytes for locals and 0 slots for call arguments.
move $r9 $$arg0               ; save arg 0
move $r0 $$arg1               ; save arg 1
move $r1 $$arg2               ; save arg 2
move $r8 $$arg3               ; save arg 3
move $r7 $$arg4               ; save arg 4
lw   $r6 $$arg5 i0            ; Load arg 5 from its stack slot
lw   $r5 $$arg5 i1            ; Load arg 6 from its stack slot
move $r4 $$reta               ; save reta
addi $r2 $$locbase i624       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i464       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i196               ; call encode_30
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i952       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i480       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i267               ; call new_32
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i664       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i696       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i520       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i304               ; call abi_encode_36
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i640       ; get offset to local
sw   $$locbase $r1 i80        ; store word
sw   $$locbase $r2 i81        ; store word
sw   $$locbase $r0 i82        ; store word
addi $r0 $$locbase i504       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i262               ; call as_raw_slice_33
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i984       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i952       ; get offset to local
addi $r1 $$locbase i768       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i455               ; call ptr_40
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i984       ; get offset to local
addi $r2 $$locbase i784       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i445               ; call ptr_40
move $r1 $$retv               ; copy the return value
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r9 $r2        ; copy memory with mem_copy
sw   $$locbase $r0 i4         ; store word
sw   $$locbase $r1 i5         ; store word
addi $r0 $$locbase i720       ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i544       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i300               ; call encode_37
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i968       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i968       ; get offset to local
addi $r1 $$locbase i800       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i417               ; call ptr_40
move $r0 $$retv               ; copy the return value
call $r0 $r8 $r7 $r6          ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i424       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i576               ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i944       ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i944       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i552               ; call abi_decode_8
move $r1 $$retv               ; copy the return value
eq   $r2 $r1 $zero
jnzf $r2 $zero i67
eq   $r1 $r1 $one
jnzf $r1 $zero i1
rvrt $zero
addi $r1 $$locbase i296       ; get offset to local
sw   $$locbase $one i37       ; store word
addi $r2 $$locbase i432       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i589               ; call abi_decode_2
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i560       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i388               ; call abi_decode_50
move $r3 $$retv               ; copy the return value
addi $r6 $$locbase i592       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r6               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i380               ; call abi_decode_50
move $r6 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i589               ; call abi_decode_8
move $r7 $$retv               ; copy the return value
lw   $r8 $r0 i0               ; load word
lb   $r8 $r8 i0               ; lb val ptr i0
lw   $r9 $r0 i0               ; load word
add  $r9 $r9 $one
sw   $r0 $r9 i0               ; store word
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i600               ; call abi_decode_8
move $r0 $$retv               ; copy the return value
addi $r9 $$locbase i176       ; get offset to local
movi $r10 i32                 ; get length for mcp
mcp  $r9 $r2 $r10             ; copy memory with mem_copy
addi $r2 $r9 i32              ; get offset to element
movi $r10 i32                 ; get length for mcp
mcp  $r2 $r3 $r10             ; copy memory with mem_copy
addi $r2 $r9 i64              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r6 $r3              ; copy memory with mem_copy
addi $r2 $r9 i96              ; get offset to element
sw   $$locbase $r7 i34        ; store word
addi $r2 $r2 i8               ; get offset to element
sb   $r2 $r8 i0               ; store byte
sw   $$locbase $r0 i36        ; store word
addi $r0 $r1 i8               ; get offset to element
movi $r2 i120                 ; get length for mcp
mcp  $r0 $r9 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i816       ; get offset to local
movi $r0 i128                 ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i5
addi $r0 $$locbase i48        ; get offset to local
sw   $$locbase $zero i6       ; store word
addi $r2 $$locbase i816       ; get offset to local
movi $r1 i128                 ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
movi $r0 i128                 ; get length for mcp
mcp  $r5 $r2 $r0              ; copy memory with mem_copy
move $$retv $r5               ; set return value
cfsi i1000                    ; free 1000 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i2047                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for encode_30
cfei i232                     ; allocate 232 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (item)
move $r8 $$arg1               ; save arg 1 (__ret_value)
move $r7 $$reta               ; save reta
addi $r1 $$locbase i144       ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i68                ; call new_32
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i104       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r2 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
addi $r2 $$locbase i128       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i24        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
lw   $r2 $$locbase i4         ; load word
movi $r3 i8                   ; initialize constant into register
add  $r2 $r2 $r3
add  $r2 $r1 $r2
gt   $r2 $r2 $r5
jnzf $r2 $zero i1
jmpf $zero i5
movi $r2 i2                   ; initialize constant into register
mul  $r5 $r5 $r2
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
addi $r2 $$locbase i40        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
add  $r0 $r6 $r1
lw   $r3 $$locbase i6
sw   $r0 $r3 i0
addi $r0 $r0 i8
lw   $r2 $$locbase i5
mcp  $r0 $r2 $r3
addi $r0 $r1 i8
add  $r0 $r0 $r3
addi $r1 $$locbase i56        ; get offset to local
sw   $$locbase $r6 i7         ; store word
sw   $$locbase $r5 i8         ; store word
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i80        ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i208       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i208       ; get offset to local
addi $r1 $$locbase i184       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i168       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i34                ; call as_raw_slice_33
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r8 $r0 $r1              ; copy memory with mem_copy
move $$retv $r8               ; set return value
cfsi i232                     ; free 232 bytes for locals and 0 slots for extra call arguments.
move $$reta $r7               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_32
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
movi $r2 i1024                ; initialize constant into register
aloc $r2
move $r2 $hp                  ; return value from inline asm (hp)
sw   $$locbase $r2 i0         ; store word
movi $r2 i1024                ; initialize constant into register
sw   $$locbase $r2 i1         ; store word
sw   $$locbase $zero i2       ; store word
move $r2 $$locbase            ; copy const asm init to GP reg
addi $r3 $$locbase i24        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r3 $r2              ; copy memory with mem_copy
move $$retv $r0               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for as_raw_slice_33
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i40        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
movi $r0 i24                  ; get length for mcp
mcp  $$locbase $r3 $r0        ; copy memory with mem_copy
lw   $r0 $$locbase i0         ; load word
addi $r3 $$locbase i16        ; get offset to element
addi $r4 $$locbase i24        ; get offset to local
sw   $$locbase $r0 i3         ; store word
addi $r0 $r4 i8               ; get offset to element
movi $r5 i8                   ; get length for mcp
mcp  $r0 $r3 $r5              ; copy memory with mem_copy
movi $r0 i16                  ; get length for mcp
mcp  $r1 $r4 $r0              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_36
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i104       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i32                  ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
addi $r4 $$locbase i24        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r4 $r0 $r7              ; copy memory with mem_copy
add  $r0 $r6 $r1
movi $r7 i32                  ; get length for mcp
mcp  $r0 $r4 $r7              ; copy memory with mem_copy
movi $r0 i32                  ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i56        ; get offset to local
sw   $$locbase $r6 i7         ; store word
sw   $$locbase $r5 i8         ; store word
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i80        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for encode_37
cfei i240                     ; allocate 240 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (item)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i111               ; call new_32
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i136       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r5 $$locbase i168       ; get offset to local
movi $r6 i24                  ; get length for mcp
mcp  $r5 $r3 $r6              ; copy memory with mem_copy
addi $r3 $$locbase i40        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i74                ; call abi_encode_36
move $r3 $$retv               ; copy the return value
lw   $r4 $r3 i0               ; load word
lw   $r5 $r3 i1               ; load word
lw   $r3 $r3 i2               ; load word
lw   $r6 $r0 i4               ; load word
addi $r7 $$locbase i192       ; get offset to local
sw   $$locbase $r4 i24        ; store word
sw   $$locbase $r5 i25        ; store word
sw   $$locbase $r3 i26        ; store word
addi $r3 $$locbase i64        ; get offset to local
move $$arg0 $r6               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i41                ; call abi_encode_39
move $r3 $$retv               ; copy the return value
lw   $r4 $r3 i0               ; load word
lw   $r5 $r3 i1               ; load word
lw   $r3 $r3 i2               ; load word
lw   $r0 $r0 i5               ; load word
addi $r6 $$locbase i216       ; get offset to local
sw   $$locbase $r4 i27        ; store word
sw   $$locbase $r5 i28        ; store word
sw   $$locbase $r3 i29        ; store word
addi $r3 $$locbase i88        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r6               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i24                ; call abi_encode_39
move $r0 $$retv               ; copy the return value
lw   $r3 $r0 i0               ; load word
lw   $r4 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r5 $$locbase i112       ; get offset to local
sw   $$locbase $r3 i14        ; store word
sw   $$locbase $r4 i15        ; store word
sw   $$locbase $r0 i16        ; store word
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i150               ; call as_raw_slice_33
move $r0 $$retv               ; copy the return value
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i240                     ; free 240 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_39
cfei i96                      ; allocate 96 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i72        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i8                   ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
add  $r4 $r6 $r1
sw   $r4 $r0 i0               ; store word
movi $r0 i8                   ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i24        ; get offset to local
sw   $$locbase $r6 i3         ; store word
sw   $$locbase $r5 i4         ; store word
sw   $$locbase $r0 i5         ; store word
addi $r0 $$locbase i48        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i96                      ; free 96 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_40
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_50
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i32        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i999               ; call abi_decode_2
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for is_none_62
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
move $r2 $zero                ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r2 $one                 ; parameter from branch to block argument
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i2047                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for contract_call_64
cfei i472                     ; allocate 472 bytes for locals and 0 slots for call arguments.
move $r10 $$arg0              ; save arg 0 (contract_id)
move $r0 $$arg1               ; save arg 1 (method_name)
move $r1 $$arg2               ; save arg 2 (args)
move $r9 $$arg3               ; save arg 3 (coins)
move $r8 $$arg4               ; save arg 4 (asset_id)
move $r7 $$arg5               ; save arg 5 (gas)
move $r6 $$reta               ; save reta
addi $r2 $$locbase i176       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i56        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i387               ; call encode_30
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i424       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i72        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i316               ; call new_32
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i216       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i248       ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i112       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i279               ; call abi_encode_36
move $r0 $$retv               ; copy the return value
lw   $r2 $r0 i0               ; load word
lw   $r3 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r1 $r1 i32              ; get offset to element
addi $r4 $$locbase i272       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i304       ; get offset to local
sw   $$locbase $r2 i38        ; store word
sw   $$locbase $r3 i39        ; store word
sw   $$locbase $r0 i40        ; store word
addi $r0 $$locbase i136       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i299               ; call abi_encode_36
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i192       ; get offset to local
sw   $$locbase $r1 i24        ; store word
sw   $$locbase $r2 i25        ; store word
sw   $$locbase $r0 i26        ; store word
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i341               ; call as_raw_slice_33
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i456       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i424       ; get offset to local
addi $r1 $$locbase i376       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i148               ; call ptr_40
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i456       ; get offset to local
addi $r2 $$locbase i392       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i158               ; call ptr_40
move $r1 $$retv               ; copy the return value
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r10 $r2       ; copy memory with mem_copy
sw   $$locbase $r0 i4         ; store word
sw   $$locbase $r1 i5         ; store word
addi $r0 $$locbase i328       ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i160       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i303               ; call encode_37
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i440       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i440       ; get offset to local
addi $r1 $$locbase i408       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i186               ; call ptr_40
move $r0 $$retv               ; copy the return value
call $r0 $r9 $r8 $r7          ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i48        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1181              ; call from_parts_1
move $$retv $zero             ; set return value
cfsi i472                     ; free 472 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i2047                    ; Restore registers 16..40
jmp $$reta                    ; return from call
.data:
data_0 .bytes[32] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
data_1 .bytes[11] 6f 72 64 65 72 5f 62 79 5f 69 64  order_by_id
data_2 .bytes[32] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
data_3 .bytes[12] 6d 61 74 63 68 5f 6f 72 64 65 72 73  match_orders
data_4 .word 18446744073709551615


   [1;32mCompiling[0m script [1mfulfill-script[0m (/home/kebradalaonda/p/compolabs-orderbook-contract/fulfill-script)
;; ASM: Final program
;; Program kind: Script
.program:
move $$tmp $pc
jmpf $zero i2
DATA_SECTION_OFFSET[0..32]
DATA_SECTION_OFFSET[32..64]
lw   $$ds $$tmp i1
add  $$ds $$ds $$tmp
cfei i32                      ; stack space for globals
addr $$arg0 data_0            ; ptr to ORDER_BOOK_CONTRACT_ID default value
addi $$arg1 $zero i32         ; length of ORDER_BOOK_CONTRACT_ID default value
addi $$arg2 $ssp i0           ; ptr to global ORDER_BOOK_CONTRACT_ID stack address
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4
jmpf $zero i154               ; decode ORDER_BOOK_CONTRACT_ID
move $$locbase $sp            ; save locals base register for __entry
cfei i376                     ; allocate 376 bytes for locals and 0 slots for call arguments.
addi $r6 $$locbase i208       ; get offset to local
gtf  $r0 $zero i10            ; get transaction field
sw   $$locbase $r0 i39        ; store word
addi $r7 $$locbase i312       ; get offset to local
move $$arg0 $r7               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i217               ; call abi_decode_8
move $r5 $$retv               ; copy the return value
movi $r0 i32                  ; initialize constant into register
mul  $r0 $r0 $r5
aloc $r0                      ; aloc size
move $r0 $hp                  ; move ptr hp
sw   $$locbase $r0 i44        ; store word
sw   $$locbase $r5 i45        ; store word
sw   $$locbase $zero i46      ; store word
move $r8 $zero                ; parameter from branch to block argument
lt   $r0 $r8 $r5
jnzf $r0 $zero i66
addi $r0 $$locbase i352       ; get offset to local
move $$arg0 $r7               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i200               ; call abi_decode_8
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i144       ; get offset to local
move $$arg0 $r7               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i219               ; call abi_decode_26
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i176       ; get offset to local
move $$arg0 $r7               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i236               ; call abi_decode_28
move $r3 $$retv               ; copy the return value
movi $r4 i24                  ; get length for mcp
mcp  $$locbase $r0 $r4        ; copy memory with mem_copy
sw   $$locbase $r1 i3         ; store word
addi $r0 $$locbase i32        ; get offset to element
movi $r1 i32                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r0 $$locbase i64        ; get offset to element
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
lw   $r0 $$locbase i3         ; load word
addi $r1 $$locbase i32        ; get offset to element
addi $r2 $$locbase i64        ; get offset to element
addi $r3 $$locbase i240       ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $$locbase $r4        ; copy memory with mem_copy
addi $r4 $$locbase i264       ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r4 $r1 $r9              ; copy memory with mem_copy
addi $r1 $$locbase i296       ; get offset to local
movi $r9 i16                  ; get length for mcp
mcp  $r1 $r2 $r9              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r4               ; pass arg 2
move $$arg3 $r1               ; pass arg 3
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i247               ; call main_34
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i192       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1164              ; call encode_40
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r6 $r0 $r1              ; copy memory with mem_copy
lw   $r0 $r6 i1               ; load size of returned slice
lw   $r6 $r6 i0               ; load ptr of returned slice
retd  $r6 $r0
addi $r0 $$locbase i112       ; get offset to local
move $$arg0 $r7               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i111               ; call abi_decode_2
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i320       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r3 $$locbase i352       ; get offset to local
addi $r4 $$locbase i320       ; get offset to local
lw   $r0 $$locbase i46        ; load word
lw   $r1 $$locbase i45        ; load word
eq   $r0 $r0 $r1
jnzf $r0 $zero i1
jmpf $zero i25
lw   $r0 $r3 i1               ; load word
eq   $r0 $r0 $zero
move $r9 $one                 ; parameter from branch to block argument
jnzf $r0 $zero i3
lw   $r0 $r3 i1               ; load word
movi $r1 i2                   ; initialize constant into register
mul  $r9 $r1 $r0
lw   $r10 $r3 i0              ; load word
lw   $r0 $r3 i1               ; load word
gt   $r1 $r9 $r0
jnzf $r1 $zero i1
jmpf $zero i11
movi $r1 i32                  ; initialize constant into register
mul  $r1 $r1 $r9
aloc $r1                      ; aloc size
move $r1 $hp                  ; move ptr hp
gt   $r2 $r0 $zero
jnzf $r2 $zero i1
jmpf $zero i3
movi $r2 i32                  ; initialize constant into register
mul  $r0 $r0 $r2
mcp  $r1 $r10 $r0             ; mcp dst src len
move $r10 $r1                 ; parameter from branch to block argument
sw   $r3 $r10 i0              ; store word
sw   $r3 $r9 i1               ; store word
addi $r0 $$locbase i224       ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i105               ; call ptr_23
move $r0 $$retv               ; copy the return value
lw   $r1 $r3 i2               ; load word
movi $r2 i32                  ; initialize constant into register
mul  $r1 $r2 $r1
add  $r0 $r0 $r1
addi $r1 $$locbase i80        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r4 $r2              ; copy memory with mem_copy
movi $r2 i32                  ; initialize constant into register
mcp  $r0 $r1 $r2              ; mcp dst src count
lw   $r0 $r3 i2               ; load word
add  $r0 $r0 $one
sw   $r3 $r0 i2               ; store word
add  $r8 $r8 $one
jmpb $zero i132
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_in_place_0
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg1               ; save arg 1 (len)
move $r3 $$arg2               ; save arg 2 (target)
move $r4 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i25                ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i40        ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i40        ; get offset to local
addi $r1 $$locbase i8         ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i25                ; call abi_decode_2
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i48        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i48        ; get offset to local
movi $r1 i32                  ; initialize constant into register
mcp  $r3 $r0 $r1              ; mcp target temp size
move $$retv $zero             ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for from_parts_1
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (ptr)
move $r1 $$arg2               ; save arg 2 (__ret_value)
move $r2 $$reta               ; save reta
sw   $r1 $r0 i0               ; store word
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_2
cfei i32                      ; allocate 32 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
lw   $r3 $r0 i0               ; load word
movi $r4 i32                  ; get length for mcp
mcp  $$locbase $r3 $r4        ; copy memory with mem_copy
lw   $r3 $r0 i0               ; load word
movi $r4 i32                  ; initialize constant into register
add  $r3 $r3 $r4
sw   $r0 $r3 i0               ; store word
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i32                      ; free 32 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_8
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$reta               ; save reta
lw   $r2 $r0 i0               ; load word
lw   $r2 $r2 i0               ; lw val ptr i0
lw   $r3 $r0 i0               ; load word
movi $r4 i8                   ; initialize constant into register
add  $r3 $r3 $r4
sw   $r0 $r3 i0               ; store word
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i3                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_23
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i3                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_26
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i32        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i61                ; call abi_decode_2
move $r0 $$retv               ; copy the return value
movi $r3 i32                  ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
movi $r0 i32                  ; get length for mcp
mcp  $r1 $$locbase $r0        ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_28
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i61                ; call abi_decode_8
move $r3 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i9                 ; call abi_decode_31
move $r0 $$retv               ; copy the return value
sw   $r1 $r3 i0               ; store word
addi $r3 $r1 i8               ; get offset to element
sb   $r3 $r0 i0               ; store byte
move $$retv $r1               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_31
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$reta               ; save reta
lw   $r2 $r0 i0               ; load word
lb   $r2 $r2 i0               ; lb val ptr i0
lw   $r3 $r0 i0               ; load word
add  $r3 $r3 $one
sw   $r0 $r3 i0               ; store word
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i16383                   ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for main_34
cfei i4200                    ; allocate 4184 bytes for locals and 2 slots for call arguments.
move $r10 $$arg0              ; save arg 0 (orders)
move $r9 $$arg1               ; save arg 1 (price)
move $r8 $$arg2               ; save arg 2 (base_token)
move $r7 $$arg3               ; save arg 3 (base_size)
move $r6 $$reta               ; save reta
load $r0 data_1               ; get local constant
load $r5 data_2               ; get local constant
addi $r1 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
sw   $$locbase $r0 i0         ; store word
movi $r0 i17                  ; initialize constant into register
sw   $$locbase $r0 i1         ; store word
addi $r0 $$locbase i256       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r0 $$locbase $r2        ; copy memory with mem_copy
addi $r2 $$locbase i1936      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1800      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i762               ; call encode_36
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i3592      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1872      ; get offset to local
move $$arg0 $zero             ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i884               ; call encode_40
move $r0 $$retv               ; copy the return value
movi $r2 i4152                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i3592      ; get offset to local
addi $r2 $$locbase i3232      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1084              ; call ptr_46
move $r0 $$retv               ; copy the return value
movi $r2 i4152                ; get offset to local
add  $r2 $$locbase $r2        ; get offset to local
addi $r3 $$locbase i3248      ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1073              ; call ptr_46
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i16        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
sw   $$locbase $r0 i6         ; store word
sw   $$locbase $r2 i7         ; store word
addi $r0 $$locbase i2720      ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i1888      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i878               ; call encode_42
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i4088      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i4088      ; get offset to local
addi $r1 $$locbase i3264      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1044              ; call ptr_46
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i368       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r5 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i368       ; get offset to local
load $r2 data_7               ; literal instantiation
call $r0 $zero $r1 $r2        ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i1152      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i237               ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3384      ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3384      ; get offset to local
addi $r1 $$locbase i1768      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i188               ; call abi_decode_26
move $r1 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1025              ; call abi_decode_49
move $r2 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1019              ; call abi_decode_49
move $r0 $$retv               ; copy the return value
addi $r3 $$locbase i64        ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
sw   $$locbase $r2 i12        ; store word
sw   $$locbase $r0 i13        ; store word
addi $r0 $$locbase i3544      ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $r3 $r1              ; copy memory with mem_copy
addi $r0 $fp i32              ; addi asset_id fp i32
addi $r1 $$locbase i136       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4120                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
move $r11 $bal                ; return value from inline asm (bal)
movi $r0 i4120                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i3544      ; get offset to local
addi $r2 $$locbase i3320      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i3352      ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r0 $r1 $r3              ; copy memory with mem_copy
wqcm $r0 $r2 $r0 i32
jnzf $r0 $zero i41
load $r0 data_3               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i680       ; get offset to local
sw   $$locbase $r0 i85        ; store word
movi $r0 i13                  ; initialize constant into register
sw   $$locbase $r0 i86        ; store word
addi $r0 $$locbase i816       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
movi $r3 i4120                ; get offset to local
add  $r3 $$locbase $r3        ; get offset to local
addi $r4 $$locbase i832       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r3 $r5              ; copy memory with mem_copy
addi $r3 $$locbase i2016      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r3 $r2 $r5              ; copy memory with mem_copy
addi $r2 $$locbase i2048      ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r2 $r0 $r5              ; copy memory with mem_copy
addi $r0 $$locbase i2064      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r0 $r4 $r5              ; copy memory with mem_copy
addi $r4 $$locbase i2096      ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_7               ; literal instantiation
move $$arg5 $r0               ; pass arg 5
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1072              ; call contract_call_67
move $r0 $$retv               ; copy the return value
load $r1 data_3               ; get local constant
load $r2 data_2               ; get local constant
load $r3 data_5               ; get local constant
move $$arg0 $r0               ; pass arg 0
movi $r0 i228                 ; initialize constant into register
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1000              ; call require_60
addi $r0 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r4 $$locbase i864       ; get offset to local
sw   $$locbase $r1 i108       ; store word
movi $r1 i13                  ; initialize constant into register
sw   $$locbase $r1 i109       ; store word
addi $r1 $$locbase i880       ; get offset to local
movi $r5 i16                  ; get length for mcp
mcp  $r1 $r4 $r5              ; copy memory with mem_copy
addi $r4 $$locbase i896       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r8 $r5              ; copy memory with mem_copy
addi $r5 $$locbase i2128      ; get offset to local
movi $r12 i32                 ; get length for mcp
mcp  $r5 $r0 $r12             ; copy memory with mem_copy
addi $r0 $$locbase i2160      ; get offset to local
movi $r12 i16                 ; get length for mcp
mcp  $r0 $r1 $r12             ; copy memory with mem_copy
addi $r1 $$locbase i2176      ; get offset to local
movi $r12 i32                 ; get length for mcp
mcp  $r1 $r4 $r12             ; copy memory with mem_copy
addi $r4 $$locbase i2232      ; get offset to local
movi $r12 i32                 ; get length for mcp
mcp  $r4 $r2 $r12             ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_7               ; literal instantiation
move $$arg5 $r0               ; pass arg 5
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1024              ; call contract_call_67
move $r0 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
movi $r0 i228                 ; initialize constant into register
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i958               ; call require_60
addi $r5 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r0 $$locbase i928       ; get offset to local
sw   $$locbase $r3 i116       ; store word
movi $r1 i10                  ; initialize constant into register
sw   $$locbase $r1 i117       ; store word
addi $r1 $$locbase i944       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r12 $$locbase i272      ; get offset to local
movi $r0 i32                  ; get length for mcp
mcp  $r12 $r8 $r0             ; copy memory with mem_copy
addi $r0 $r12 i32             ; get offset to element
movi $r2 i16                  ; get length for mcp
mcp  $r0 $r7 $r2              ; copy memory with mem_copy
sw   $$locbase $r9 i40        ; store word
movi $r7 i4120                ; get offset to local
add  $r7 $$locbase $r7        ; get offset to local
addi $r0 $$locbase i1952      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i1816      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i504               ; call encode_36
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3608      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1832      ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i575               ; call new_38
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2264      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r12 $r2             ; copy memory with mem_copy
addi $r2 $$locbase i2296      ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i1248      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i1105              ; call abi_encode_70
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3424      ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $r12 i32             ; get offset to element
addi $r1 $$locbase i3424      ; get offset to local
lw   $r2 $r12 i4              ; load word
addi $r3 $$locbase i3184      ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
addi $r1 $$locbase i1200      ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i763               ; call abi_encode_45
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i3448      ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r0 $r0 i8               ; get offset to element
addi $r1 $$locbase i3448      ; get offset to local
addi $r2 $$locbase i960       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i112       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r1 $r2 $r3              ; copy memory with mem_copy
lw   $r4 $$locbase i14        ; load word
lw   $r3 $$locbase i15        ; load word
lw   $r1 $$locbase i16        ; load word
add  $r2 $r1 $one
gt   $r2 $r2 $r3
jnzf $r2 $zero i1
jmpf $zero i5
movi $r2 i2                   ; initialize constant into register
mul  $r3 $r3 $r2
aloc $r3
mcp  $hp $r4 $r1
move $r4 $hp                  ; return value from inline asm (hp)
load $r13 data_6              ; get local constant
load $r9 data_2               ; get local constant
add  $r2 $r4 $r1
movi $r8 i1                   ; get length for mcp
mcp  $r2 $r0 $r8              ; copy memory with mem_copy
add  $r0 $r1 $one
addi $r1 $$locbase i328       ; get offset to local
sw   $$locbase $r4 i41        ; store word
sw   $$locbase $r3 i42        ; store word
sw   $$locbase $r0 i43        ; store word
addi $r0 $$locbase i792       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i3496      ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3496      ; get offset to local
addi $r1 $$locbase i3472      ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $r12 i6              ; load word
addi $r1 $$locbase i3472      ; get offset to local
addi $r2 $$locbase i3208      ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i1224      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r1               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i704               ; call abi_encode_45
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3520      ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3520      ; get offset to local
addi $r1 $$locbase i3400      ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3400      ; get offset to local
addi $r1 $$locbase i2208      ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1856      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i489               ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
movi $r1 i4168                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3608      ; get offset to local
addi $r1 $$locbase i1968      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i716               ; call ptr_46
move $r0 $$retv               ; copy the return value
movi $r1 i4168                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
addi $r2 $$locbase i1984      ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i705               ; call ptr_46
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i168       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r5 $r3              ; copy memory with mem_copy
sw   $$locbase $r0 i25        ; store word
sw   $$locbase $r1 i26        ; store word
addi $r0 $$locbase i3104      ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
addi $r1 $$locbase i1904      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i510               ; call encode_42
move $r0 $$retv               ; copy the return value
movi $r1 i4104                ; get offset to local
add  $r1 $$locbase $r1        ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
movi $r0 i4104                ; get offset to local
add  $r0 $$locbase $r0        ; get offset to local
addi $r1 $$locbase i2000      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i674               ; call ptr_46
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i400       ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r7 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i400       ; get offset to local
load $r2 data_7               ; literal instantiation
call $r0 $r11 $r1 $r2         ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i1160      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i607               ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3392      ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3392      ; get offset to local
addi $r1 $$locbase i1168      ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i607               ; call abi_decode_2
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3776      ; get offset to local
movi $r2 i32                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r1 $$locbase i352       ; get offset to local
sw   $$locbase $r13 i44       ; store word
movi $r2 i11                  ; initialize constant into register
sw   $$locbase $r2 i45        ; store word
addi $r2 $$locbase i472       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i3776      ; get offset to local
addi $r3 $$locbase i488       ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r1 $r4              ; copy memory with mem_copy
addi $r1 $$locbase i2576      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r1 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i2608      ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i2624      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r2 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i2656      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r9 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i1512      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r3               ; pass arg 4
load $r0 data_7               ; literal instantiation
sw   $$locbase $r0 i523       ; Pass arg 5 via its stack slot
sw   $$locbase $r4 i524       ; Pass arg 6 via its stack slot
movi $$arg5 i4184             ; Temporarily save the locals size to add up next
add  $$arg5 $$locbase $$arg5  ; Save address of stack arguments in last arg register
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i937               ; call contract_call_80
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i2320      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1272      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i904               ; call unwrap_79
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3656      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3656      ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r7 $r0 i0               ; load byte
move $r5 $zero                ; parameter from branch to block argument
lw   $r0 $r10 i2              ; load word
lt   $r0 $r5 $r0
jnzf $r0 $zero i2
move $$retv $zero             ; set return value
jmpf $zero i225
lw   $r0 $r10 i2              ; load word
lt   $r1 $r0 $r5
jnzf $r1 $zero i1
eq   $r1 $r0 $r5
jnzf $r1 $zero i21
addi $r0 $$locbase i1920      ; get offset to local
movi $r1 i16                  ; get length for mcp
mcp  $r0 $r10 $r1             ; copy memory with mem_copy
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i650               ; call ptr_23
move $r0 $$retv               ; copy the return value
movi $r1 i32                  ; initialize constant into register
mul  $r1 $r1 $r5
add  $r0 $r0 $r1
addi $r1 $$locbase i432       ; get offset to local
sw   $$locbase $one i54       ; store word
addi $r2 $r1 i8               ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r2 $$locbase i3280      ; get offset to local
movi $r0 i40                  ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i5
addi $r0 $$locbase i216       ; get offset to local
sw   $$locbase $zero i27      ; store word
addi $r2 $$locbase i3280      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
addi $r0 $$locbase i1112      ; get offset to local
movi $r1 i40                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
lw   $r0 $$locbase i139       ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
load $r0 data_6               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $$locbase i1112      ; get offset to local
addi $r2 $r2 i8               ; get offset to element
addi $r3 $$locbase i3624      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i3624      ; get offset to local
addi $r3 $$locbase i3928      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i520       ; get offset to local
sw   $$locbase $r0 i65        ; store word
movi $r0 i11                  ; initialize constant into register
sw   $$locbase $r0 i66        ; store word
addi $r0 $$locbase i536       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i3928      ; get offset to local
addi $r4 $$locbase i552       ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r4 $r3 $r8              ; copy memory with mem_copy
addi $r3 $$locbase i2688      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r3 $r2 $r8              ; copy memory with mem_copy
addi $r2 $$locbase i2768      ; get offset to local
movi $r8 i16                  ; get length for mcp
mcp  $r2 $r0 $r8              ; copy memory with mem_copy
addi $r0 $$locbase i2784      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r0 $r4 $r8              ; copy memory with mem_copy
addi $r4 $$locbase i2816      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r4 $r1 $r8              ; copy memory with mem_copy
addi $r1 $$locbase i1640      ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_7               ; literal instantiation
sw   $$locbase $r0 i523       ; Pass arg 5 via its stack slot
sw   $$locbase $r1 i524       ; Pass arg 6 via its stack slot
movi $$arg5 i4184             ; Temporarily save the locals size to add up next
add  $$arg5 $$locbase $$arg5  ; Save address of stack arguments in last arg register
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i822               ; call contract_call_80
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3960      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3960      ; get offset to local
addi $r1 $$locbase i984       ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
lw   $r0 $$locbase i123       ; load word
eq   $r0 $r0 $one
move $r1 $zero                ; parameter from branch to block argument
jnzf $r0 $zero i1
move $r1 $one                 ; parameter from branch to block argument
jnzf $r1 $zero i119
addi $r0 $$locbase i3960      ; get offset to local
addi $r1 $$locbase i2448      ; get offset to local
movi $r2 i128                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i1392      ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i775               ; call unwrap_79
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i3808      ; get offset to local
movi $r2 i120                 ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i3808      ; get offset to local
addi $r0 $r0 i96              ; get offset to element
addi $r0 $r0 i8               ; get offset to element
lb   $r0 $r0 i0               ; load byte
move $r1 $r7                  ; parameter from branch to block argument
jnzf $r7 $zero i1
jmpf $zero i1
eq   $r1 $r0 $zero
jnzf $r1 $zero i50
eq   $r1 $r7 $zero
jnzf $r1 $zero i1
jmpf $zero i1
move $r1 $r0                  ; parameter from branch to block argument
jnzf $r1 $zero i1
jmpf $zero i43
load $r0 data_4               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i696       ; get offset to local
sw   $$locbase $r0 i87        ; store word
movi $r0 i12                  ; initialize constant into register
sw   $$locbase $r0 i88        ; store word
addi $r0 $$locbase i712       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i3808      ; get offset to local
addi $r4 $$locbase i3656      ; get offset to local
addi $r8 $$locbase i728       ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r8 $r3 $r9              ; copy memory with mem_copy
addi $r3 $r8 i32              ; get offset to element
movi $r9 i32                  ; get length for mcp
mcp  $r3 $r4 $r9              ; copy memory with mem_copy
addi $r3 $$locbase i2992      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i3024      ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i3040      ; get offset to local
movi $r4 i64                  ; get length for mcp
mcp  $r0 $r8 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i3152      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r4 $r1 $r8              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_7               ; literal instantiation
move $$arg5 $r0               ; pass arg 5
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i949               ; call contract_call_96
jmpf $zero i43
load $r0 data_4               ; get local constant
load $r1 data_2               ; get local constant
addi $r2 $ssp i0              ; configurable ORDER_BOOK_CONTRACT_ID address
addi $r3 $$locbase i584       ; get offset to local
sw   $$locbase $r0 i73        ; store word
movi $r0 i12                  ; initialize constant into register
sw   $$locbase $r0 i74        ; store word
addi $r0 $$locbase i600       ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r0 $r3 $r4              ; copy memory with mem_copy
addi $r3 $$locbase i3656      ; get offset to local
addi $r4 $$locbase i3808      ; get offset to local
addi $r8 $$locbase i616       ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r8 $r3 $r9              ; copy memory with mem_copy
addi $r3 $r8 i32              ; get offset to element
movi $r9 i32                  ; get length for mcp
mcp  $r3 $r4 $r9              ; copy memory with mem_copy
addi $r3 $$locbase i2848      ; get offset to local
movi $r4 i32                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
addi $r2 $$locbase i2880      ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r2 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i2896      ; get offset to local
movi $r4 i64                  ; get length for mcp
mcp  $r0 $r8 $r4              ; copy memory with mem_copy
addi $r4 $$locbase i2960      ; get offset to local
movi $r8 i32                  ; get length for mcp
mcp  $r4 $r1 $r8              ; copy memory with mem_copy
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
move $$arg3 $zero             ; pass arg 3
move $$arg4 $r4               ; pass arg 4
load $r0 data_7               ; literal instantiation
move $$arg5 $r0               ; pass arg 5
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i905               ; call contract_call_96
add  $r5 $r5 $one
jmpb $zero i226
add  $r5 $r5 $one
jmpb $zero i228
cfsi i4200                    ; free 4184 bytes for locals and 2 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i16383                   ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for encode_36
cfei i232                     ; allocate 232 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (item)
move $r8 $$arg1               ; save arg 1 (__ret_value)
move $r7 $$reta               ; save reta
addi $r1 $$locbase i144       ; get offset to local
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i68                ; call new_38
move $r1 $$retv               ; copy the return value
addi $r2 $$locbase i104       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r2 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
addi $r2 $$locbase i128       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i24        ; get offset to local
movi $r4 i16                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
lw   $r2 $$locbase i4         ; load word
movi $r3 i8                   ; initialize constant into register
add  $r2 $r2 $r3
add  $r2 $r1 $r2
gt   $r2 $r2 $r5
jnzf $r2 $zero i1
jmpf $zero i5
movi $r2 i2                   ; initialize constant into register
mul  $r5 $r5 $r2
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
addi $r2 $$locbase i40        ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
add  $r0 $r6 $r1
lw   $r3 $$locbase i6
sw   $r0 $r3 i0
addi $r0 $r0 i8
lw   $r2 $$locbase i5
mcp  $r0 $r2 $r3
addi $r0 $r1 i8
add  $r0 $r0 $r3
addi $r1 $$locbase i56        ; get offset to local
sw   $$locbase $r6 i7         ; store word
sw   $$locbase $r5 i8         ; store word
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i80        ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r1 $r2              ; copy memory with mem_copy
addi $r1 $$locbase i208       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i208       ; get offset to local
addi $r1 $$locbase i184       ; get offset to local
movi $r2 i24                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i168       ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i34                ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $r8 $r0 $r1              ; copy memory with mem_copy
move $$retv $r8               ; set return value
cfsi i232                     ; free 232 bytes for locals and 0 slots for extra call arguments.
move $$reta $r7               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i31                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for new_38
cfei i48                      ; allocate 48 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (__ret_value)
move $r1 $$reta               ; save reta
movi $r2 i1024                ; initialize constant into register
aloc $r2
move $r2 $hp                  ; return value from inline asm (hp)
sw   $$locbase $r2 i0         ; store word
movi $r2 i1024                ; initialize constant into register
sw   $$locbase $r2 i1         ; store word
sw   $$locbase $zero i2       ; store word
move $r2 $$locbase            ; copy const asm init to GP reg
addi $r3 $$locbase i24        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r2 $r4              ; copy memory with mem_copy
movi $r2 i24                  ; get length for mcp
mcp  $r0 $r3 $r2              ; copy memory with mem_copy
move $$retv $r0               ; set return value
cfsi i48                      ; free 48 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i31                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for as_raw_slice_39
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
addi $r3 $$locbase i40        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
movi $r0 i24                  ; get length for mcp
mcp  $$locbase $r3 $r0        ; copy memory with mem_copy
lw   $r0 $$locbase i0         ; load word
addi $r3 $$locbase i16        ; get offset to element
addi $r4 $$locbase i24        ; get offset to local
sw   $$locbase $r0 i3         ; store word
addi $r0 $r4 i8               ; get offset to element
movi $r5 i8                   ; get length for mcp
mcp  $r0 $r3 $r5              ; copy memory with mem_copy
movi $r0 i16                  ; get length for mcp
mcp  $r1 $r4 $r0              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for encode_40
cfei i64                      ; allocate 64 bytes for locals and 0 slots for call arguments.
move $r0 $$arg1               ; save arg 1 (__ret_value)
move $r1 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i61                ; call new_38
move $r2 $$retv               ; copy the return value
lw   $r3 $r2 i0               ; load word
lw   $r4 $r2 i1               ; load word
lw   $r2 $r2 i2               ; load word
addi $r5 $$locbase i40        ; get offset to local
sw   $$locbase $r3 i5         ; store word
sw   $$locbase $r4 i6         ; store word
sw   $$locbase $r2 i7         ; store word
addi $r2 $$locbase i24        ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i51                ; call as_raw_slice_39
move $r2 $$retv               ; copy the return value
movi $r3 i16                  ; get length for mcp
mcp  $r0 $r2 $r3              ; copy memory with mem_copy
move $$retv $r0               ; set return value
cfsi i64                      ; free 64 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for encode_42
cfei i240                     ; allocate 240 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (item)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
move $$arg0 $$locbase         ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i97                ; call new_38
move $r3 $$retv               ; copy the return value
addi $r4 $$locbase i136       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r0 $r5              ; copy memory with mem_copy
addi $r5 $$locbase i168       ; get offset to local
movi $r6 i24                  ; get length for mcp
mcp  $r5 $r3 $r6              ; copy memory with mem_copy
addi $r3 $$locbase i40        ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r5               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i58                ; call abi_encode_44
move $r3 $$retv               ; copy the return value
lw   $r4 $r3 i0               ; load word
lw   $r5 $r3 i1               ; load word
lw   $r3 $r3 i2               ; load word
lw   $r6 $r0 i4               ; load word
addi $r7 $$locbase i192       ; get offset to local
sw   $$locbase $r4 i24        ; store word
sw   $$locbase $r5 i25        ; store word
sw   $$locbase $r3 i26        ; store word
addi $r3 $$locbase i64        ; get offset to local
move $$arg0 $r6               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i90                ; call abi_encode_45
move $r3 $$retv               ; copy the return value
lw   $r4 $r3 i0               ; load word
lw   $r5 $r3 i1               ; load word
lw   $r3 $r3 i2               ; load word
lw   $r0 $r0 i5               ; load word
addi $r6 $$locbase i216       ; get offset to local
sw   $$locbase $r4 i27        ; store word
sw   $$locbase $r5 i28        ; store word
sw   $$locbase $r3 i29        ; store word
addi $r3 $$locbase i88        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r6               ; pass arg 1
move $$arg2 $r3               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i73                ; call abi_encode_45
move $r0 $$retv               ; copy the return value
lw   $r3 $r0 i0               ; load word
lw   $r4 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r5 $$locbase i112       ; get offset to local
sw   $$locbase $r3 i14        ; store word
sw   $$locbase $r4 i15        ; store word
sw   $$locbase $r0 i16        ; store word
addi $r0 $$locbase i24        ; get offset to local
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i136               ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
movi $r3 i16                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i240                     ; free 240 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i255                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_44
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i104       ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i32                  ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
addi $r4 $$locbase i24        ; get offset to local
movi $r7 i32                  ; get length for mcp
mcp  $r4 $r0 $r7              ; copy memory with mem_copy
add  $r0 $r6 $r1
movi $r7 i32                  ; get length for mcp
mcp  $r0 $r4 $r7              ; copy memory with mem_copy
movi $r0 i32                  ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i56        ; get offset to local
sw   $$locbase $r6 i7         ; store word
sw   $$locbase $r5 i8         ; store word
sw   $$locbase $r0 i9         ; store word
addi $r0 $$locbase i80        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i255                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i127                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_45
cfei i96                      ; allocate 96 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (buffer)
move $r2 $$arg2               ; save arg 2 (__ret_value)
move $r3 $$reta               ; save reta
addi $r4 $$locbase i72        ; get offset to local
movi $r5 i24                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $$locbase $r4 $r1        ; copy memory with mem_copy
lw   $r6 $$locbase i0         ; load word
lw   $r5 $$locbase i1         ; load word
lw   $r1 $$locbase i2         ; load word
movi $r4 i8                   ; initialize constant into register
add  $r4 $r1 $r4
gt   $r4 $r4 $r5
jnzf $r4 $zero i1
jmpf $zero i5
movi $r4 i2                   ; initialize constant into register
mul  $r5 $r5 $r4
aloc $r5
mcp  $hp $r6 $r1
move $r6 $hp                  ; return value from inline asm (hp)
add  $r4 $r6 $r1
sw   $r4 $r0 i0               ; store word
movi $r0 i8                   ; initialize constant into register
add  $r0 $r1 $r0
addi $r1 $$locbase i24        ; get offset to local
sw   $$locbase $r6 i3         ; store word
sw   $$locbase $r5 i4         ; store word
sw   $$locbase $r0 i5         ; store word
addi $r0 $$locbase i48        ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r0 $r1 $r4              ; copy memory with mem_copy
movi $r1 i24                  ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
move $$retv $r2               ; set return value
cfsi i96                      ; free 96 bytes for locals and 0 slots for extra call arguments.
move $$reta $r3               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i127                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i7                       ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for ptr_46
cfei i16                      ; allocate 16 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
movi $r2 i16                  ; get length for mcp
mcp  $$locbase $r0 $r2        ; copy memory with mem_copy
move $r0 $$locbase            ; copy const asm init to GP reg
lw   $r0 $r0 i0               ; load word
move $$retv $r0               ; set return value
cfsi i16                      ; free 16 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i7                       ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_decode_49
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (buffer)
move $r1 $$reta               ; save reta
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i39                ; call read_51
move $r2 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i33                ; call read_51
move $r3 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i27                ; call read_51
move $r4 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i21                ; call read_51
move $r0 $$retv               ; copy the return value
movi $r5 i24                  ; initialize constant into register
sll  $r2 $r2 $r5
load $r5 data_8               ; literal instantiation
and  $r2 $r2 $r5
movi $r5 i16                  ; initialize constant into register
sll  $r3 $r3 $r5
load $r5 data_8               ; literal instantiation
and  $r3 $r3 $r5
or   $r2 $r2 $r3
movi $r3 i8                   ; initialize constant into register
sll  $r3 $r4 $r3
load $r4 data_8               ; literal instantiation
and  $r3 $r3 $r4
or   $r2 $r2 $r3
or   $r0 $r2 $r0
move $$retv $r0               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for read_51
cfei i0                       ; allocate 0 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$reta               ; save reta
lw   $r2 $r0 i0               ; load word
lb   $r2 $r2 i0               ; lb val ptr i0
lw   $r3 $r0 i0               ; load word
add  $r3 $r3 $one
sw   $r0 $r3 i0               ; store word
move $$retv $r2               ; set return value
cfsi i0                       ; free 0 bytes for locals and 0 slots for extra call arguments.
move $$reta $r1               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for require_60
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (condition)
move $r1 $$arg1               ; save arg 1 (value)
move $r2 $$reta               ; save reta
eq   $r0 $r0 $zero
jnzf $r0 $zero i2
move $$retv $zero             ; set return value
jmpf $zero i42
addi $r0 $$locbase i16        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i361               ; call new_38
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i104       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i56        ; get offset to local
move $$arg0 $r1               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i152               ; call abi_encode_45
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i80        ; get offset to local
sw   $$locbase $r1 i10        ; store word
sw   $$locbase $r2 i11        ; store word
sw   $$locbase $r0 i12        ; store word
addi $r0 $$locbase i40        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i363               ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
movi $r1 i16                  ; get length for mcp
mcp  $$locbase $r0 $r1        ; copy memory with mem_copy
load $r0 data_9               ; literal instantiation
lw   $r1 $$locbase i0         ; load slice ptr
lw   $r2 $$locbase i1         ; load slice size
logd $zero $r0 $r1 $r2        ; log slice
load $r0 data_10              ; literal instantiation
rvrt $r0
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i511                     ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for contract_call_67
cfei i400                     ; allocate 400 bytes for locals and 0 slots for call arguments.
move $r8 $$arg0               ; save arg 0 (contract_id)
move $r0 $$arg1               ; save arg 1 (method_name)
move $r1 $$arg2               ; save arg 2 (args)
move $r7 $$arg3               ; save arg 3 (coins)
move $r6 $$arg4               ; save arg 4 (asset_id)
move $r5 $$arg5               ; save arg 5 (gas)
move $r4 $$reta               ; save reta
addi $r2 $$locbase i152       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i56        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i504               ; call encode_36
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i352       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i72        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i433               ; call new_38
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i288       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i320       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i128       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpf $zero i95                ; call abi_encode_70
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i168       ; get offset to local
sw   $$locbase $r1 i21        ; store word
sw   $$locbase $r2 i22        ; store word
sw   $$locbase $r0 i23        ; store word
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i438               ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i384       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i352       ; get offset to local
addi $r1 $$locbase i240       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i210               ; call ptr_46
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i384       ; get offset to local
addi $r2 $$locbase i256       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i220               ; call ptr_46
move $r1 $$retv               ; copy the return value
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r8 $r2        ; copy memory with mem_copy
sw   $$locbase $r0 i4         ; store word
sw   $$locbase $r1 i5         ; store word
addi $r0 $$locbase i192       ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i112       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i414               ; call encode_42
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i368       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i368       ; get offset to local
addi $r1 $$locbase i272       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i248               ; call ptr_46
move $r0 $$retv               ; copy the return value
call $r0 $r7 $r6 $r5          ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i48        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1526              ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i344       ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i344       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1424              ; call abi_decode_31
move $r0 $$retv               ; copy the return value
move $$retv $r0               ; set return value
cfsi i400                     ; free 400 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i511                     ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i63                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for abi_encode_70
cfei i80                      ; allocate 80 bytes for locals and 0 slots for call arguments.
move $r1 $$arg0               ; save arg 0 (self)
move $r2 $$arg1               ; save arg 1 (buffer)
move $r3 $$arg2               ; save arg 2 (__ret_value)
move $r4 $$reta               ; save reta
addi $r5 $$locbase i24        ; get offset to local
movi $r0 i32                  ; get length for mcp
mcp  $r5 $r1 $r0              ; copy memory with mem_copy
addi $r0 $$locbase i56        ; get offset to local
movi $r1 i24                  ; get length for mcp
mcp  $r0 $r2 $r1              ; copy memory with mem_copy
move $$arg0 $r5               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
move $$arg2 $$locbase         ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i392               ; call abi_encode_44
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
sw   $r3 $r1 i0               ; store word
sw   $r3 $r2 i1               ; store word
sw   $r3 $r0 i2               ; store word
move $$retv $r3               ; set return value
cfsi i80                      ; free 80 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i63                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i15                      ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for unwrap_79
cfei i128                     ; allocate 128 bytes for locals and 0 slots for call arguments.
move $r0 $$arg0               ; save arg 0 (self)
move $r1 $$arg1               ; save arg 1 (__ret_value)
move $r2 $$reta               ; save reta
movi $r3 i128                 ; get length for mcp
mcp  $$locbase $r0 $r3        ; copy memory with mem_copy
lw   $r0 $r0 i0               ; load word
eq   $r0 $r0 $one
jnzf $r0 $zero i1
rvrt $zero
addi $r0 $$locbase i8         ; get offset to element
movi $r3 i120                 ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
move $$retv $r1               ; set return value
cfsi i128                     ; free 128 bytes for locals and 0 slots for extra call arguments.
move $$reta $r2               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i15                      ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i1023                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for contract_call_80
cfei i1016                    ; allocate 1016 bytes for locals and 0 slots for call arguments.
move $r9 $$arg0               ; save arg 0
move $r0 $$arg1               ; save arg 1
move $r1 $$arg2               ; save arg 2
move $r8 $$arg3               ; save arg 3
move $r7 $$arg4               ; save arg 4
lw   $r6 $$arg5 i0            ; Load arg 5 from its stack slot
lw   $r5 $$arg5 i1            ; Load arg 6 from its stack slot
move $r4 $$reta               ; save reta
addi $r2 $$locbase i640       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i544       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i702               ; call encode_36
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i968       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i560       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i631               ; call new_38
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i776       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r1 $$locbase i808       ; get offset to local
movi $r3 i24                  ; get length for mcp
mcp  $r1 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i616       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i101               ; call abi_encode_70
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i656       ; get offset to local
sw   $$locbase $r1 i82        ; store word
sw   $$locbase $r2 i83        ; store word
sw   $$locbase $r0 i84        ; store word
addi $r0 $$locbase i584       ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i636               ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1000      ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i968       ; get offset to local
addi $r1 $$locbase i728       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i408               ; call ptr_46
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i1000      ; get offset to local
addi $r2 $$locbase i744       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i418               ; call ptr_46
move $r1 $$retv               ; copy the return value
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r9 $r2        ; copy memory with mem_copy
sw   $$locbase $r0 i4         ; store word
sw   $$locbase $r1 i5         ; store word
addi $r0 $$locbase i680       ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i600       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i612               ; call encode_42
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i984       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i984       ; get offset to local
addi $r1 $$locbase i760       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i446               ; call ptr_46
move $r0 $$retv               ; copy the return value
call $r0 $r8 $r7 $r6          ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i424       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1724              ; call from_parts_1
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i960       ; get offset to local
movi $r2 i8                   ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i960       ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1700              ; call abi_decode_8
move $r1 $$retv               ; copy the return value
eq   $r2 $r1 $zero
jnzf $r2 $zero i63
eq   $r1 $r1 $one
jnzf $r1 $zero i1
rvrt $zero
addi $r1 $$locbase i296       ; get offset to local
sw   $$locbase $one i37       ; store word
addi $r2 $$locbase i432       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r2               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1737              ; call abi_decode_2
move $r2 $$retv               ; copy the return value
addi $r3 $$locbase i464       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1696              ; call abi_decode_26
move $r3 $$retv               ; copy the return value
addi $r6 $$locbase i496       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r6               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1704              ; call abi_decode_26
move $r6 $$retv               ; copy the return value
addi $r7 $$locbase i528       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r7               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1687              ; call abi_decode_28
move $r7 $$retv               ; copy the return value
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1745              ; call abi_decode_8
move $r0 $$retv               ; copy the return value
addi $r8 $$locbase i176       ; get offset to local
movi $r9 i32                  ; get length for mcp
mcp  $r8 $r2 $r9              ; copy memory with mem_copy
addi $r2 $r8 i32              ; get offset to element
movi $r9 i32                  ; get length for mcp
mcp  $r2 $r3 $r9              ; copy memory with mem_copy
addi $r2 $r8 i64              ; get offset to element
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r6 $r3              ; copy memory with mem_copy
addi $r2 $r8 i96              ; get offset to element
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r7 $r3              ; copy memory with mem_copy
sw   $$locbase $r0 i36        ; store word
addi $r0 $r1 i8               ; get offset to element
movi $r2 i120                 ; get length for mcp
mcp  $r0 $r8 $r2              ; copy memory with mem_copy
addi $r2 $$locbase i832       ; get offset to local
movi $r0 i128                 ; get length for mcp
mcp  $r2 $r1 $r0              ; copy memory with mem_copy
jmpf $zero i5
addi $r0 $$locbase i48        ; get offset to local
sw   $$locbase $zero i6       ; store word
addi $r2 $$locbase i832       ; get offset to local
movi $r1 i128                 ; get length for mcp
mcp  $r2 $r0 $r1              ; copy memory with mem_copy
movi $r0 i128                 ; get length for mcp
mcp  $r5 $r2 $r0              ; copy memory with mem_copy
move $$retv $r5               ; set return value
cfsi i1016                    ; free 1016 bytes for locals and 0 slots for extra call arguments.
move $$reta $r4               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i1023                    ; Restore registers 16..40
jmp $$reta                    ; return from call
pshl i2047                    ; Save registers 16..40
pshh i524288                  ; Save registers 40..64
move $$locbase $sp            ; save locals base register for contract_call_96
cfei i472                     ; allocate 472 bytes for locals and 0 slots for call arguments.
move $r10 $$arg0              ; save arg 0 (contract_id)
move $r0 $$arg1               ; save arg 1 (method_name)
move $r1 $$arg2               ; save arg 2 (args)
move $r9 $$arg3               ; save arg 3 (coins)
move $r8 $$arg4               ; save arg 4 (asset_id)
move $r7 $$arg5               ; save arg 5 (gas)
move $r6 $$reta               ; save reta
addi $r2 $$locbase i176       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i56        ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i915               ; call encode_36
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i424       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r0 $r3              ; copy memory with mem_copy
addi $r0 $$locbase i72        ; get offset to local
move $$arg0 $r0               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i844               ; call new_38
move $r0 $$retv               ; copy the return value
addi $r2 $$locbase i264       ; get offset to local
movi $r3 i32                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
addi $r3 $$locbase i296       ; get offset to local
movi $r4 i24                  ; get length for mcp
mcp  $r3 $r0 $r4              ; copy memory with mem_copy
addi $r0 $$locbase i128       ; get offset to local
move $$arg0 $r2               ; pass arg 0
move $$arg1 $r3               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i687               ; call abi_encode_44
move $r0 $$retv               ; copy the return value
lw   $r2 $r0 i0               ; load word
lw   $r3 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r1 $r1 i32              ; get offset to element
addi $r4 $$locbase i320       ; get offset to local
movi $r5 i32                  ; get length for mcp
mcp  $r4 $r1 $r5              ; copy memory with mem_copy
addi $r1 $$locbase i352       ; get offset to local
sw   $$locbase $r2 i44        ; store word
sw   $$locbase $r3 i45        ; store word
sw   $$locbase $r0 i46        ; store word
addi $r0 $$locbase i152       ; get offset to local
move $$arg0 $r4               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r0               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i707               ; call abi_encode_44
move $r0 $$retv               ; copy the return value
lw   $r1 $r0 i0               ; load word
lw   $r2 $r0 i1               ; load word
lw   $r0 $r0 i2               ; load word
addi $r3 $$locbase i192       ; get offset to local
sw   $$locbase $r1 i24        ; store word
sw   $$locbase $r2 i25        ; store word
sw   $$locbase $r0 i26        ; store word
addi $r0 $$locbase i96        ; get offset to local
move $$arg0 $r3               ; pass arg 0
move $$arg1 $r0               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i869               ; call as_raw_slice_39
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i456       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i424       ; get offset to local
addi $r1 $$locbase i376       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i641               ; call ptr_46
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i456       ; get offset to local
addi $r2 $$locbase i392       ; get offset to local
movi $r3 i16                  ; get length for mcp
mcp  $r2 $r1 $r3              ; copy memory with mem_copy
move $$arg0 $r2               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i651               ; call ptr_46
move $r1 $$retv               ; copy the return value
movi $r2 i32                  ; get length for mcp
mcp  $$locbase $r10 $r2       ; copy memory with mem_copy
sw   $$locbase $r0 i4         ; store word
sw   $$locbase $r1 i5         ; store word
addi $r0 $$locbase i216       ; get offset to local
movi $r1 i48                  ; get length for mcp
mcp  $r0 $$locbase $r1        ; copy memory with mem_copy
addi $r1 $$locbase i112       ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i845               ; call encode_42
move $r0 $$retv               ; copy the return value
addi $r1 $$locbase i440       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
addi $r0 $$locbase i440       ; get offset to local
addi $r1 $$locbase i408       ; get offset to local
movi $r2 i16                  ; get length for mcp
mcp  $r1 $r0 $r2              ; copy memory with mem_copy
move $$arg0 $r1               ; pass arg 0
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i679               ; call ptr_46
move $r0 $$retv               ; copy the return value
call $r0 $r9 $r8 $r7          ; call external contract
move $r0 $ret                 ; return value from inline asm (ret)
move $r1 $retl                ; return value from inline asm (retl)
addi $r2 $$locbase i48        ; get offset to local
move $$arg0 $r0               ; pass arg 0
move $$arg1 $r1               ; pass arg 1
move $$arg2 $r2               ; pass arg 2
sub  $$reta $pc $is           ; Get current instruction offset from Instruction start
srli $$reta $$reta i2         ; Current instruction offset in 32b words
addi $$reta $$reta i4         ; set new return addr
jmpb $zero i1957              ; call from_parts_1
move $$retv $zero             ; set return value
cfsi i472                     ; free 472 bytes for locals and 0 slots for extra call arguments.
move $$reta $r6               ; restore reta
poph i524288                  ; Restore registers 40..64
popl i2047                    ; Restore registers 16..40
jmp $$reta                    ; return from call
.data:
data_0 .bytes[32] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
data_1 .bytes[17] 67 65 74 5f 63 6f 6e 66 69 67 75 72 61 62 6c 65 73  get_configurables
data_2 .bytes[32] 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
data_3 .bytes[13] 6d 61 72 6b 65 74 5f 65 78 69 73 74 73  market_exists
data_4 .bytes[12] 6d 61 74 63 68 5f 6f 72 64 65 72 73  match_orders
data_5 .bytes[10] 6f 70 65 6e 5f 6f 72 64 65 72  open_order
data_6 .bytes[11] 6f 72 64 65 72 5f 62 79 5f 69 64  order_by_id
data_7 .word 18446744073709551615
data_8 .word 4294967295
data_9 .word 1515152261580153489
data_10 .word 18446744073709486080
